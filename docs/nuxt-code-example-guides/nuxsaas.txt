Directory structure:
└── nuxsaas-nuxsaas/
    ├── README.md
    ├── eslint.config.mjs
    ├── LICENSE
    ├── nuxt.config.ts
    ├── package.json
    ├── tsconfig.json
    ├── vitest.config.ts
    ├── wrangler.example.toml
    ├── .env.example
    ├── .nvmrc
    ├── app/
    │   ├── app.config.ts
    │   ├── app.vue
    │   ├── assets/
    │   │   └── css/
    │   │       └── main.css
    │   ├── components/
    │   │   ├── FlexThreeColumn.vue
    │   │   ├── Logo.vue
    │   │   ├── SiteNavigation.vue
    │   │   ├── UserNavigation.vue
    │   │   ├── AdminTable/
    │   │   │   ├── index.vue
    │   │   │   ├── types.ts
    │   │   │   ├── components/
    │   │   │   │   ├── ColumnControl.vue
    │   │   │   │   ├── filters/
    │   │   │   │   │   ├── DateRange.vue
    │   │   │   │   │   ├── Tabs.vue
    │   │   │   │   │   └── Checkbox/
    │   │   │   │   │       ├── i18n.json
    │   │   │   │   │       └── index.vue
    │   │   │   │   ├── Pagination/
    │   │   │   │   │   ├── i18n.json
    │   │   │   │   │   └── index.vue
    │   │   │   │   └── SortControl/
    │   │   │   │       ├── i18n.json
    │   │   │   │       ├── index.vue
    │   │   │   │       └── SortableContent.vue
    │   │   │   └── composables/
    │   │   │       ├── useColumnControl.ts
    │   │   │       └── useSelectControl.ts
    │   │   ├── ColorModeToggler/
    │   │   │   ├── i18n.json
    │   │   │   └── index.vue
    │   │   └── LocaleToggler/
    │   │       ├── i18n.json
    │   │       └── index.vue
    │   ├── composables/
    │   │   ├── useAdminTable.ts
    │   │   ├── useAuth.ts
    │   │   └── useCustomFetch.ts
    │   ├── i18n/
    │   │   ├── global.json
    │   │   └── i18n.config.ts
    │   ├── layouts/
    │   │   ├── admin.vue
    │   │   ├── default.vue
    │   │   ├── components/
    │   │   │   ├── AppFooter.vue
    │   │   │   ├── AppNavbar.vue
    │   │   │   └── SearchPalette.vue
    │   │   └── menu/
    │   │       ├── i18n.json
    │   │       └── index.ts
    │   ├── middleware/
    │   │   └── auth.global.ts
    │   ├── pages/
    │   │   ├── admin.vue
    │   │   ├── index.json
    │   │   ├── index.vue
    │   │   ├── 403/
    │   │   │   ├── i18n.json
    │   │   │   └── index.vue
    │   │   ├── admin/
    │   │   │   ├── dashboard/
    │   │   │   │   ├── i18n.json
    │   │   │   │   └── index.vue
    │   │   │   ├── maintenance/
    │   │   │   │   ├── audit-log/
    │   │   │   │   │   ├── i18n.json
    │   │   │   │   │   └── index.vue
    │   │   │   │   ├── db-stats/
    │   │   │   │   │   ├── i18n.json
    │   │   │   │   │   └── index.vue
    │   │   │   │   └── migration/
    │   │   │   │       ├── i18n.json
    │   │   │   │       └── index.vue
    │   │   │   ├── subscription/
    │   │   │   │   ├── i18n.json
    │   │   │   │   └── index.vue
    │   │   │   └── user/
    │   │   │       ├── i18n.json
    │   │   │       ├── index.vue
    │   │   │       └── components/
    │   │   │           ├── BanUserModal.vue
    │   │   │           └── CreateUserModal.vue
    │   │   ├── forgot-password/
    │   │   │   ├── i18n.json
    │   │   │   └── index.vue
    │   │   ├── pricing/
    │   │   │   ├── i18n.json
    │   │   │   └── index.vue
    │   │   ├── profile/
    │   │   │   ├── i18n.json
    │   │   │   └── index.vue
    │   │   ├── reset-password/
    │   │   │   ├── i18n.json
    │   │   │   └── index.vue
    │   │   ├── signin/
    │   │   │   ├── i18n.json
    │   │   │   └── index.vue
    │   │   └── signup/
    │   │       ├── i18n.json
    │   │       └── index.vue
    │   ├── plugins/
    │   │   ├── auth.client.ts
    │   │   ├── auth.server.ts
    │   │   └── customFetch.ts
    │   └── utils/
    │       ├── columns.ts
    │       ├── components.ts
    │       ├── date.ts
    │       └── types.ts
    ├── public/
    │   ├── favicons/
    │   │   └── site.webmanifest
    │   └── screenshots/
    │       ├── dashboard.webp
    │       ├── home.webp
    │       ├── pricing.webp
    │       ├── signin.webp
    │       ├── subscription.webp
    │       └── users.webp
    ├── server/
    │   ├── tsconfig.json
    │   ├── api/
    │   │   ├── admin/
    │   │   │   ├── count/
    │   │   │   │   └── [tableName]/
    │   │   │   │       └── [columnName].get.ts
    │   │   │   ├── list/
    │   │   │   │   └── [tableName].get.ts
    │   │   │   └── maintenance/
    │   │   │       ├── db-stats.ts
    │   │   │       └── ensure-payment-customers.ts
    │   │   └── auth/
    │   │       └── [...all].ts
    │   ├── database/
    │   │   ├── drizzle.config.ts
    │   │   └── schema/
    │   │       ├── auditLog.ts
    │   │       ├── auth.ts
    │   │       └── index.ts
    │   ├── middleware/
    │   │   ├── 0.common.ts
    │   │   └── 1.auth.ts
    │   ├── types/
    │   │   └── hub.d.ts
    │   └── utils/
    │       ├── auditLogger.ts
    │       ├── auth.ts
    │       ├── db.ts
    │       ├── dbStats.ts
    │       ├── drivers.ts
    │       ├── polar.ts
    │       ├── query.ts
    │       ├── runtimeConfig.ts
    │       └── stripe.ts
    ├── shared/
    │   └── utils/
    │       └── types.ts
    ├── tests/
    │   ├── setup.ts
    │   └── e2e/
    │       ├── app.test.ts
    │       ├── auth.test.ts
    │       ├── i18n.test.ts
    │       ├── signin.test.ts
    │       └── signup.test.ts
    ├── .github/
    │   └── FUNDING.yml
    └── .husky/
        └── pre-commit

================================================
FILE: README.md
================================================
<p align="center">
  <img src="public/logo.svg" alt="NuxSaaS Logo" width="160" height="160"/>
</p>

<h1 align="center">NuxSaaS</h1>

<p align="center">
  <a href="https://nuxsaas.com" target="_blank">Website</a> ·
  <a href="https://docs.nuxsaas.com" target="_blank">Documentation</a> ·
  <a href="https://discord.gg/8V4kSu43MW" target="_blank">Discord</a> ·
  <a href="https://www.youtube.com/watch?v=u1H8ChQ5Pl8" target="_blank">Youtube</a> ·
  <a href="https://x.com/cyanhall" target="_blank">
    @Cyanhall
  </a>
</p>

<p align="center">
  <a href="https://nuxt.com/" target="_blank">
    <img alt="Built with Nuxt 4" src="https://img.shields.io/badge/Built%20with-Nuxt%204-00DC82?style=flat-square&logo=nuxt.js" />
  </a>
  <a href="https://www.typescriptlang.org/" target="_blank">
    <img alt="Language TypeScript" src="https://img.shields.io/badge/Language-TypeScript-blue?style=flat-square&logo=typescript" />
  </a>
  <a href="https://www.postgresql.org/" target="_blank">
    <img alt="Database PostgreSQL" src="https://img.shields.io/badge/Database-PostgreSQL-blue?style=flat-square&logo=postgresql" />
  </a>
  <a href="https://tailwindcss.com/" target="_blank">
    <img alt="Tailwind CSS" src="https://img.shields.io/badge/Styling-Tailwind%20CSS-38B2AC?style=flat-square&logo=tailwind-css" />
  </a>
  <a href="https://github.com/NuxSaaS/NuxSaaS/blob/main/LICENSE" target="_blank">
    <img alt="License MIT" src="https://img.shields.io/badge/License-MIT-yellow.svg?style=flat-square" />
  </a>
</p>

<p align="center">
  <b>Nuxt.js Full-Stack SaaS Starter Kit - Free & Open Source</b>
  <br />
  Modern, Production-Ready, and Developer-Friendly
</p>

## ✨ Features

- 🚀 **Modern Tech Stack** - Built with Nuxt 4, Vue 3, TypeScript
- 🔒 **Secure Auth** - Better Auth with OAuth2 social logins
- 💾 **Enterprise Database** - PostgreSQL with Drizzle ORM
- 💳 **Payment Ready** - Stripe/Polar integration for subscription
- 📧 **Email Integration** - Built-in Resend support
- 📊 **Beautiful Dashboard** - Admin panel with charts
- 🌐 **I18n Ready** - Multi-language support out of the box
- 📱 **Responsive** - Mobile-first design approach
- 🎯 **Developer Experience** - ESLint + TypeScript for better DX

## 🚀 Quick Start

```bash
# 1. Clone the repository
git clone https://github.com/NuxSaaS/NuxSaaS.git
cd NuxSaaS

# 2. Use Node.js v22 LTS
nvm use

# 3. Install dependencies
npm install

# 4. Setup environment variables
cp .env.example .env

# 5. Generate and apply database migrations
npm run db:generate
npm run db:migrate

# 6. Start development server
npm run dev
```

## 🚀 Deployment
#### Node.js Server
```bash
# Deploy to self host server
npm run build
npm run serve
```

#### Cloudflare Worker
```bash
# Deploy to Cloudflare Worker
npm run build
cp wrangler.example.toml wrangler.toml
npm run deploy
```

## 🌟 Support

If you find this project helpful, please consider:
- Giving it a star ⭐
- [Becoming a sponsor on Patreon](https://patreon.com/NuxSaaS) 💖

Your support helps maintain and improve NuxSaaS!

## 🙏 Credits
This project is built upon these amazing open source projects:
- [Nuxt](https://nuxt.com) - The Progressive Web Framework
- [Nuxt UI](https://ui.nuxt.com) - Fully styled and customizable components
- [Better Auth](https://github.com/better-auth/better-auth) -The most comprehensive authentication framework for TypeScript
- [Drizzle ORM](https://github.com/drizzle-team/drizzle-orm) - TypeScript ORM
- [TailwindCSS](https://tailwindcss.com) - Utility-first CSS framework
- [nuxt-charts](https://github.com/dennisadriaans/vue-chrts): Nuxt module for Unovis
- [nuxthub-better-auth](https://github.com/atinux/nuxthub-better-auth): A demo of using Better Auth with Nuxt

## 📜 License
This project is licensed under the [MIT License](LICENSE).



================================================
FILE: eslint.config.mjs
================================================
// @ts-check
import antfu from '@antfu/eslint-config'
import withNuxt from './.nuxt/eslint.config.mjs'

export default withNuxt(
  antfu({
    // ...@antfu/eslint-config options
    // Vue ESLint Rule: https://eslint.vuejs.org/rules/
    markdown: false,
    rules: {
      'style/comma-dangle': ['warn', 'never'],
      'style/brace-style': 'off',
      'style/operator-linebreak': 'off',
      'vue/comma-dangle': 'off',
      'vue/eqeqeq': 'off',
      'vue/max-attributes-per-line': 'warn',
      'vue/no-unused-refs': 'off',
      'antfu/top-level-function': 'off',
      'node/prefer-global/process': 'off',
      'eqeqeq': 'off',
      'no-console': 'off',
      'no-debugger': 'off',
      'no-async-promise-executor': 'off'
    }
  })
  // Your custom configs here
)



================================================
FILE: LICENSE
================================================
The MIT License (MIT)

Copyright (c) 2025-present - NuxSaaS

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.


================================================
FILE: nuxt.config.ts
================================================
// https://nuxt.com/docs/api/configuration/nuxt-config
import type { NuxtPage } from 'nuxt/schema'
import { generateRuntimeConfig } from './server/utils/runtimeConfig'

console.log(`Current NODE_ENV: ${process.env.NODE_ENV}`)

export default defineNuxtConfig({
  compatibilityDate: '2025-07-22',
  devtools: { enabled: true },
  css: ['~/assets/css/main.css'],
  modules: [
    '@nuxt/ui',
    '@nuxt/eslint',
    '@nuxtjs/i18n',
    '@nuxtjs/seo',
    'nuxt-charts',
    ...(process.env.NODE_ENV === 'test' ? ['@nuxt/test-utils/module'] : []),
    ...(process.env.NUXT_NITRO_PRESET !== 'node-server' ? ['@nuxthub/core'] : [])
  ],
  ...(process.env.NUXT_NITRO_PRESET !== 'node-server'
    ? {
        hub: {
          workers: true,
          kv: true,
          bindings: {
            hyperdrive: {
              HYPERDRIVE: process.env.NUXT_CF_HYPERDRIVE_ID as string
            }
          }
        }
      }
    : {}),
  i18n: {
    vueI18n: '~/i18n/i18n.config.ts',
    baseUrl: process.env.NUXT_APP_URL,
    locales: [
      { code: 'en', language: 'en-US', name: 'English' },
      { code: 'zh-CN', language: 'zh-CN', name: '简体中文' },
      { code: 'ja', language: 'ja-JP', name: '日本語' },
      { code: 'fr', language: 'fr-FR', name: 'Français' }
    ],
    defaultLocale: 'en',
    bundle: {
      optimizeTranslationDirective: false
    }
  },
  sitemap: {
    exclude: [
      '/admin/**',
      '/403',
      '/profile'
    ]
  },
  seo: {
    canonicalLowercase: false
  },
  robots: {
    disallow: [
      '/admin',
      '/profile'
    ]
  },
  eslint: {
    config: {
      standalone: false
    }
  },
  fonts: {
    provider: 'local'
  },
  ogImage: {
    enabled: false
  },
  icon: {
    serverBundle: false,
    clientBundle: {
      scan: {
        globInclude: ['**\/*.{vue,jsx,tsx,md,mdc,mdx}', 'app/**/*.ts']
      }
    }
  },
  future: {
    compatibilityVersion: 4
  },
  hooks: {
    'pages:extend': function (pages) {
      const pagesToRemove: NuxtPage[] = []
      pages.forEach((page) => {
        if (page.path.includes('component') || page.path.includes('/api')) {
          pagesToRemove.push(page)
        }
      })

      pagesToRemove.forEach((page: NuxtPage) => {
        pages.splice(pages.indexOf(page), 1)
      })
      // Uncomment to show current Routes
      // console.log(`\nCurrent Routes:`)
      // console.log(pages)
      // console.log(`\n`)
    }
  },
  runtimeConfig: generateRuntimeConfig(),
  app: {
    head: {
      charset: 'utf-8',
      viewport: 'width=device-width, initial-scale=1, maximum-scale=5.0, minimum-scale=1.0',
      link: [
        { rel: 'icon', type: 'image/png', href: '/favicons/favicon-96x96.png', sizes: '96x96' },
        { rel: 'icon', type: 'image/svg+xml', href: '/logo.svg' },
        { rel: 'shortcut icon', href: '/favicon.ico' },
        { rel: 'apple-touch-icon', sizes: '180x180', href: '/favicons/apple-touch-icon.png' },
        { rel: 'manifest', href: '/favicons/site.webmanifest' }
      ],
      meta: [
        { name: 'apple-mobile-web-app-title', content: process.env.NUXT_APP_NAME }
      ]
    }
  },
  nitro: {
    preset: process.env.NUXT_NITRO_PRESET,
    rollupConfig: {
      external: process.env.NUXT_NITRO_PRESET != 'node-server' ? ['pg-native'] : undefined
    }
  }
})



================================================
FILE: package.json
================================================
{
  "name": "nuxsaas",
  "type": "module",
  "private": true,
  "scripts": {
    "dev": "nuxt dev",
    "test": "vitest run --silent=false",
    "coverage": "vitest run --coverage",
    "generate": "nuxt generate",
    "preview": "nuxt preview",
    "postinstall": "nuxt prepare",
    "lint": "eslint .",
    "lint:fix": "eslint --fix .",
    "auth:schema": "npx @better-auth/cli generate --config server/utils/auth.ts --output server/database/schema/auth.ts -y",
    "db:generate": "drizzle-kit generate --config ./server/database/drizzle.config.ts",
    "db:migrate": "drizzle-kit migrate --config ./server/database/drizzle.config.ts",
    "build": "nuxt build",
    "serve": "node .output/server/index.mjs",
    "preview:cf": "wrangler dev",
    "deploy": "wrangler deploy",
    "prepare": "husky"
  },
  "dependencies": {
    "@better-auth/stripe": "^1.3.2",
    "@nuxt/ui": "^3.2.0",
    "@nuxthub/core": "^0.9.0",
    "@nuxtjs/i18n": "^9.5.6",
    "@nuxtjs/seo": "^3.1.0",
    "@polar-sh/better-auth": "^1.0.7",
    "@polar-sh/sdk": "^0.34.6",
    "@vueuse/core": "13.5.0",
    "@vueuse/integrations": "^13.5.0",
    "better-auth": "^1.3.2",
    "date-fns": "^4.1.0",
    "dotenv": "^16.6.1",
    "drizzle-orm": "0.44.3",
    "ioredis": "^5.6.1",
    "nuxt": "^4.0.1",
    "nuxt-charts": "^0.2.0-test.21",
    "ofetch": "^1.4.1",
    "pg": "^8.16.3",
    "resend": "^4.7.0",
    "sortablejs": "^1.15.6",
    "stripe": "^18.3.0",
    "uuid": "^11.1.0",
    "vue": "^3.5.17",
    "vue-component-type-helpers": "3.0.3",
    "zod": "^3"
  },
  "devDependencies": {
    "@antfu/eslint-config": "^4.17.0",
    "@better-auth/cli": "^1.3.2",
    "@iconify-json/lucide": "^1.2.57",
    "@iconify-json/simple-icons": "^1.2.44",
    "@nuxt/eslint": "^1.6.0",
    "@nuxt/test-utils": "^3.19.2",
    "@types/pg": "^8.15.4",
    "@vitejs/plugin-vue": "^6.0.0",
    "@vitest/coverage-v8": "^3.2.4",
    "@vue/test-utils": "^2.4.6",
    "drizzle-kit": "^0.31.4",
    "eslint": "^9.31.0",
    "happy-dom": "^18.0.1",
    "husky": "^9.1.7",
    "playwright-core": "^1.54.1",
    "tailwindcss": "^4.1.11",
    "typescript": "^5.8.3",
    "vitest": "^3.2.4",
    "wrangler": "^4.25.0"
  }
}



================================================
FILE: tsconfig.json
================================================
{
  // https://nuxt.com/docs/guide/concepts/typescript
  "extends": "./.nuxt/tsconfig.json"
}



================================================
FILE: vitest.config.ts
================================================
import { defineVitestConfig } from '@nuxt/test-utils/config'

export default defineVitestConfig({
  test: {
    testTimeout: 30000,
    environment: 'nuxt',
    environmentOptions: {
      nuxt: {
        domEnvironment: 'happy-dom',
        overrides: {
          // other Nuxt config you want to pass
        }
      }
    },
    coverage: {
      reporter: ['html'],
      reportsDirectory: '../tests/coverage'
    },
    setupFiles: './tests/setup.ts'
  }
})



================================================
FILE: wrangler.example.toml
================================================
name = "nuxsaas"
compatibility_date = "2024-11-01"
compatibility_flags = [ "nodejs_compat" ]
main = "./dist/server/index.mjs"
assets = { directory = "./dist/public/", binding = "ASSETS" }
kv_namespaces = [ { binding = "KV", id = "your_kv_id" } ]
routes = [ { pattern = "nuxsaas.com", custom_domain = true } ]

[observability.logs]
enabled = true

[[hyperdrive]]
binding = "HYPERDRIVE"
id = "your_hyperdrive_id"



================================================
FILE: .env.example
================================================
# Description: Example of .env file
NUXT_NITRO_PRESET=node-server # node-server or cloudflare-module
NUXT_CF_HYPERDRIVE_ID=cloudflare-hyperdrive-id #  Required when using cloudflare-module

NUXT_APP_URL=http://localhost:3000 # Base URL of your app
NUXT_APP_NAME=NuxSaaS
NUXT_APP_NOTIFY_EMAIL="noreply@nuxsaas.com"
NUXT_APP_CONTACT_EMAIL="contact@nuxsaas.com"
NUXT_APP_REPO=https://github.com/NuxSaaS/NuxSaaS

NUXT_BETTER_AUTH_SECRET='' # Secret key for JWT

NUXT_DATABASE_URL=postgres://postgres:@localhost:5432/nuxsaas
NUXT_REDIS_URL=redis://localhost:6379

NUXT_GH_CLIENT_ID=your-github-client-id
NUXT_GH_CLIENT_SECRET=your-github-client-secret

NUXT_GOOGLE_CLIENT_ID=your-google-client-id
NUXT_GOOGLE_CLIENT_SECRET=your-google-client-secret

NUXT_RESEND_API_KEY=your-resend-api-key

NUXT_PAYMENT=stripe # stripe or polar

NUXT_STRIPE_SECRET_KEY=your-stripe-secret-key
NUXT_STRIPE_WEBHOOK_SECRET=your-stripe-webhook-key
NUXT_STRIPE_PRICE_ID_PRO_MONTH=your-stripe-price-id-pro-month
NUXT_STRIPE_PRICE_ID_PRO_YEAR=your-stripe-price-id-pro-year

NUXT_POLAR_SERVER=sandbox # sandbox or production
NUXT_POLAR_ACCESS_TOKEN=your-polar-access-token
NUXT_POLAR_WEBHOOK_SECRET=your-polar-webhook-secret
NUXT_POLAR_PRODUCT_ID_PRO_MONTH=your-polar-product-id-pro-month
NUXT_POLAR_PRODUCT_ID_PRO_YEAR=your-polar-product-id-pro-year

# For testing
NUXT_TEST_DATABASE_URL=postgres://postgres:@localhost:5432/nuxsaas_test
NUXT_TEST_APP_URL=http://localhost:3000 # App URL for e2e test
NUXT_TEST_EMAIL=test@nuxsaas.com
NUXT_TEST_PASSWORD=test-password
NUXT_ADMIN_EMAIL=admin@nuxsaas.com
NUXT_ADMIN_PASSWORD=admin-password


================================================
FILE: .nvmrc
================================================
22.17


================================================
FILE: app/app.config.ts
================================================
export default defineAppConfig({
  // https://ui3.nuxt.dev/getting-started/theme#design-system
  ui: {
    colors: {
      primary: 'emerald',
      neutral: 'slate'
    },
    button: {
      defaultVariants: {
        // Set default button color to neutral
        // color: 'neutral'
      }
    }
  }
})



================================================
FILE: app/app.vue
================================================
<script lang="ts" setup>
const { t } = useI18n()

// Zod locale configuration
const { locale } = useI18n()

const updateZodLocale = (newLocale: string) => {
  const localeKey = newLocale.replace('-', '') as keyof typeof zodLocales
  if (z.locales[localeKey]) {
    z.config(z.locales[localeKey]())
  } else {
    console.warn(`Zod locale "${localeKey}" not found, falling back to English.`)
    z.config(z.locales.en())
  }
}

watchEffect(() => {
  updateZodLocale(locale.value)
})

useHead({
  titleTemplate: (title) => {
    if (title) {
      if (title.includes(t('global.appName'))) {
        return title
      } else {
        return `${title} | ${t('global.appName')}`
      }
    } else {
      return t('global.appName')
    }
  }
})
useSeoMeta({
  ogSiteName: t('global.appName')
})
</script>

<template>
  <UApp>
    <NuxtLayout>
      <NuxtPage />
    </NuxtLayout>
  </UApp>
</template>



================================================
FILE: app/assets/css/main.css
================================================
@import "tailwindcss";
@import "@nuxt/ui";

@theme {
  --font-sans: 'Public Sans', sans-serif;
}
@layer base {
  body {
    @apply bg-gray-100 dark:bg-gray-950;
  }
}


================================================
FILE: app/components/FlexThreeColumn.vue
================================================
<template>
  <div class="flex items-center justify-between flex-1 gap-x-1.5">
    <slot>
      <div class="flex items-center gap-1.5">
        <slot name="left" />
      </div>
      <div class="flex items-center gap-1.5">
        <slot name="middle" />
      </div>
      <div class="flex items-center gap-1.5">
        <slot name="right" />
      </div>
    </slot>
  </div>
</template>



================================================
FILE: app/components/Logo.vue
================================================
<template>
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="100%"
    height="100%"
    viewBox="-6 -6 110 100"
    preserveAspectRatio="xMidYMid meet"
    class="text-primary dark:text-primary"
  >
    <g
      fill="currentColor"
      stroke="currentColor"
      stroke-width="8"
    >
      <g transform="matrix(.69 0 0 .69 15.5 15.5)">
        <path
          d="M10.18 70.12l4.94-9.89c.38-.77.34-1.68-.11-2.41a2.47 2.47 0 0 0-2.1-1.17H2.23l28.01-51.7 25.01 45.48c.44.79 1.27 1.28 2.17 1.28h11.26c.88 0 1.69-.46 2.13-1.22.45-.76.46-1.69.03-2.45L32.38-21.19c-.87-1.57-3.45-1.57-4.32 0l-49.45 89c-.43.77-.41 1.7.03 2.46.44.75 1.25 1.22 2.13 1.22h27.2c.94-.01 1.79-.53 2.21-1.37"
          transform="translate(-1, 0)"
        />
        <path
          d="M121.39 67.81l-49.45-89c-.45-.8-1.38-1.25-2.22-1.27-.92.02-1.75.55-2.16 1.37L55.2 3.63c-.35.69-.35 1.51 0 2.21l4.94 9.89c.84 1.68 3.59 1.68 4.43 0l5.29-10.59 27.9 51.51h-52.7c-1.36 0-2.47 1.11-2.47 2.47v9.89c0 1.36 1.11 2.47 2.47 2.47h74.17c.88 0 1.69-.46 2.13-1.22.44-.75.45-1.68.03-2.45"
          transform="translate(1, 0)"
        />
        <path
          d="M89.25 77.7a2.48 2.48 0 0 0-2.16-1.27H74.72c-.89 0-1.71.48-2.15 1.25-.44.78-.43 1.73.03 2.49l5.17 8.62H22.15L47.2 45.53c.42-.72.45-1.6.07-2.34l-4.94-9.89a2.477 2.477 0 0 0-2.14-1.37c-.92-.04-1.77.45-2.22 1.25L18.23 67.72-1.55 99.86a2.46 2.46 0 0 0-.05 2.5 2.48 2.48 0 0 0 2.16 1.27h98.89c.88 0 1.69-.46 2.13-1.22.44-.75.45-1.69.03-2.46L89.25 77.7z"
          transform="translate(3, 2)"
        />
      </g>
    </g>
  </svg>
</template>



================================================
FILE: app/components/SiteNavigation.vue
================================================
<script setup lang="ts">
const { mode } = defineProps<{
  mode: 'desktop' | 'mobile'
}>()

const { t } = useI18n()
const localePath = useLocalePath()

const navigation = [
  { label: t('global.nav.features'), to: localePath('/#features') },
  { label: t('global.nav.pricing'), to: localePath('/pricing') },
  { label: t('global.nav.docs'), to: 'https://docs.nuxsaas.com/', external: true }
]
</script>

<template>
  <div>
    <!-- Desktop Navigation -->
    <div
      v-if="mode === 'desktop'"
      class="flex items-center gap-8"
    >
      <template
        v-for="item in navigation"
        :key="item.label"
      >
        <NuxtLink
          v-if="!item.external"
          :to="item.to"
          class="text-sm font-medium text-gray-700 hover:text-primary-500 dark:text-gray-300 dark:hover:text-primary-400"
        >
          {{ item.label }}
        </NuxtLink>
        <a
          v-else
          :href="item.to"
          target="_blank"
          rel="noopener noreferrer"
          class="text-sm font-medium text-gray-700 hover:text-primary-500 dark:text-gray-300 dark:hover:text-primary-400"
        >
          {{ item.label }}
        </a>
      </template>
    </div>

    <!-- Mobile Navigation -->
    <div v-if="mode === 'mobile'">
      <UDropdownMenu :items="navigation">
        <UButton
          color="neutral"
          variant="ghost"
          icon="i-lucide-menu"
          aria-label="menu"
        />
      </UDropdownMenu>
    </div>
  </div>
</template>



================================================
FILE: app/components/UserNavigation.vue
================================================
<script setup lang="ts">
const localePath = useLocalePath()
const { t } = useI18n()
const { loggedIn, signOut, user, activeStripeSubscription, activePolarSubscriptions } = useAuth()
</script>

<template>
  <template v-if="loggedIn">
    <UDropdownMenu
      :items="[
        {
          label: t('global.auth.profile'),
          icon: 'i-lucide-user',
          to: localePath('/profile')
        },
        {
          label: t('global.auth.signOut'),
          icon: 'i-lucide-log-out',
          onSelect: () => signOut()
        }
      ]"
    >
      <UButton
        variant="ghost"
        color="neutral"
        class="flex items-center gap-2"
      >
        <UAvatar
          v-if="user?.image"
          :src="user?.image"
          :alt="user?.name"
          size="sm"
        />
        <span>
          {{ user?.name }}
          <UBadge
            v-if="activeStripeSubscription || activePolarSubscriptions?.length"
            label="Pro"
          />
        </span>
      </UButton>
    </UDropdownMenu>
    <UButton
      v-if="user?.role == 'admin'"
      variant="outline"
      color="neutral"
      class="flex items-center gap-2"
      :to="localePath('/admin')"
    >
      {{ t('global.nav.admin') }}
    </UButton>
  </template>
  <template v-else>
    <UButton
      :to="localePath('/signin')"
      variant="outline"
    >
      {{ t('global.auth.signIn') }}
    </UButton>
  </template>
</template>



================================================
FILE: app/components/AdminTable/index.vue
================================================
<script setup lang="ts" generic="T">
import type { UTableInstance } from './types'
import { useDebounceFn } from '@vueuse/core'
import { FetchError } from 'ofetch'
import { useRoute, useRouter } from 'vue-router'
import ColumnControl from './components/ColumnControl.vue'
import FilterCheckbox from './components/filters/Checkbox/index.vue'
import FilterDateRange from './components/filters/DateRange.vue'
import FilterTabs from './components/filters/Tabs.vue'
import Pagination from './components/Pagination/index.vue'
import SortControl from './components/SortControl/index.vue'
import useColumnControl from './composables/useColumnControl'
import useSelectControl from './composables/useSelectControl'

const { fetchData, columns, filters = [], hidePagination = false, canSelect = false, rowId } = defineProps<{
  fetchData: FetchDataFn<T>
  columns: AdminTableColumn<T>[]
  filters?: AdminTableFilter[]
  hidePagination?: boolean
  canSelect?: boolean
  rowId?: string
}>()

const route = useRoute()
const router = useRouter()
const toast = useToast()

const page = ref<number>(Number(route.query.page) || 1)
const limit = ref<number>(Number(route.query.limit) || 20)
const loading = ref(false)
const total = ref(0)
const data = ref<any[]>([])
const rowSelection = defineModel<Record<string, boolean>>('rowSelection', { default: {} })

const sortOptions = ref<SortOption[]>([])

const tableRef = useTemplateRef<UTableInstance>('table')
const { selectedColumns } = useColumnControl(columns, tableRef)
const { selectColumnId, getRowId, selectedRowCount, rowCount } = useSelectControl(tableRef, rowId)

const fetchTableData = useDebounceFn(async () => {
  loading.value = true
  try {
    const filter: FilterCondition[] = []
    for (const item of filters) {
      if (item.type === 'input') {
        if (item.value) {
          filter.push({ col: item.field, op: 'like', v: item.value })
        }
      } else if (item.type === 'checkbox') {
        if (item.value.length) {
          filter.push({ col: item.field, op: 'in', v: item.value })
        }
      } else if (item.type === 'tabs') {
        if (item.value) {
          filter.push({ col: item.field, op: 'eq', v: item.value })
        }
      } else if (item.type === 'daterange') {
        const { start, end } = item.value
        if (start && end) {
          filter.push({
            col: item.field,
            op: 'between',
            v: [formatToDate(start).toISOString(), endOfDate(formatToDate(end)).toISOString()]
          })
        }
      }
    }
    const result = await fetchData({
      page: page.value,
      limit: limit.value,
      sort: sortOptions.value,
      filter
    })
    data.value = result.data || []
    total.value = result.total || 0
  } catch (error: unknown) {
    if (error instanceof FetchError) {
      toast.add({
        description: error.data?.message || error.message,
        color: 'error',
        icon: 'i-lucide-alert-circle'
      })
    }
    console.error('Error fetching data:', error)
    loading.value = false
  } finally {
    loading.value = false
  }
})

// Watch sortOptions and sync to URL
watch(
  () => sortOptions.value,
  (newSortOptions) => {
    const query = { ...route.query }
    if (newSortOptions.length) {
      query.sort = JSON.stringify(newSortOptions)
    } else {
      delete query.sort
    }
    router.replace({ query })
    fetchTableData()
  },
  { immediate: true, deep: true }
)

// Watch page and limit and sync to URL
watch(
  [page, limit],
  ([newPage, newLimit]) => {
    const query = { ...route.query, page: newPage, limit: newLimit }
    router.replace({ query })
    fetchTableData()
  }
)

const updatePage = (value: number) => {
  page.value = value
}

const updateLimit = (value: number) => {
  limit.value = value
}

const refreshSuccess = ref(false)

const handleRefresh = async () => {
  refreshSuccess.value = false
  await fetchTableData()
  refreshSuccess.value = true
  setTimeout(() => {
    refreshSuccess.value = false
  }, 1000)
}

onMounted(() => {
  if (route.query.sort) {
    try {
      sortOptions.value = JSON.parse(route.query.sort as string)
    } catch {
      sortOptions.value = []
    }
  }
  fetchTableData()
})

defineExpose({
  fetchTableData
})
</script>

<template>
  <div class="max-h-full flex flex-col">
    <FlexThreeColumn class="max-w-full overflow-x-scroll flex-none">
      <template #left>
        <slot name="top-left-before" />
        <template
          v-for="(filter, index) in filters"
          :key="index"
        >
          <UInput
            v-if="filter.type === 'input'"
            v-model="filter.value"
            :placeholder="`${filter.name}...`"
            @update:model-value="fetchTableData"
          />
          <FilterCheckbox
            v-else-if="filter.type === 'checkbox'"
            v-model:filter="filter.value"
            :filter-name="filter.field"
            :name="filter.name"
            :items="filter.items"
            @update:filter="fetchTableData"
          />
          <FilterTabs
            v-else-if="filter.type === 'tabs'"
            v-model:filter="filter.value"
            :filter-name="filter.field"
            :name="filter.name"
            :items="filter.items"
            @update:filter="fetchTableData"
          />
          <FilterDateRange
            v-else-if="filter.type === 'daterange'"
            v-model:date-range="filter.value"
            :filter-name="filter.field"
            :name="filter.name"
            @update:date-range="fetchTableData"
          />
        </template>
        <slot name="top-left-after" />
      </template>
      <template #right>
        <slot name="top-right" />
        <UButton
          :color="refreshSuccess ? 'success' : 'neutral'"
          variant="outline"
          :icon="loading ? 'i-lucide-loader-2' : (refreshSuccess ? 'i-lucide-check' : 'i-lucide-refresh-cw')"
          :loading="loading"
          @click="handleRefresh"
        />
        <SortControl
          v-model:sort-options="sortOptions"
          :columns="columns"
        />
        <ColumnControl
          v-model:selected-columns="selectedColumns"
          :columns="columns"
        />
      </template>
    </FlexThreeColumn>
    <UTable
      ref="table"
      v-model:row-selection="rowSelection"
      :get-row-id="getRowId"
      :loading="loading"
      :columns="canSelect ? [{ id: selectColumnId }, ...columns] : columns"
      :data="data"
      sticky
      class="flex-1"
    >
      <template #[`${selectColumnId}-header`]="{ table }">
        <UCheckbox
          :model-value="table.getIsSomePageRowsSelected()
            ? 'indeterminate'
            : table.getIsAllPageRowsSelected()"
          @update:model-value="(value: boolean | 'indeterminate') =>
            table.toggleAllPageRowsSelected(!!value)"
        />
      </template>
      <template #[`${selectColumnId}-cell`]="{ row }">
        <UCheckbox
          :model-value="row.getIsSelected()"
          @update:model-value="(value: boolean | 'indeterminate') => row.toggleSelected(!!value)"
        />
      </template>
      <template
        v-for="(_, name) in $slots"
        :key="name"
        #[name]="slotData"
      >
        <slot
          :name="name"
          v-bind="slotData"
        />
      </template>
    </UTable>
    <Pagination
      :page="page"
      :limit="limit"
      :total="total"
      :hide-pagination="hidePagination"
      :can-select="canSelect"
      :selected-row-count="selectedRowCount"
      :row-count="rowCount"
      @update:page="updatePage"
      @update:limit="updateLimit"
    />
  </div>
</template>



================================================
FILE: app/components/AdminTable/types.ts
================================================
import type { ComponentExposed } from 'vue-component-type-helpers'

export type UTableInstance = ComponentExposed<typeof UTable>



================================================
FILE: app/components/AdminTable/components/ColumnControl.vue
================================================
<script setup lang="ts" generic="T">
const { columns } = defineProps<{
  columns: AdminTableColumn<T>[]
}>()

const selectedColumns = defineModel<string[]>('selectedColumns', { default: [] })

const columnOptions = computed(() => columns.filter(column => column.accessorKey))

const columnItems = computed(() => columnOptions.value.map(column => ({
  label: column.header,
  type: 'checkbox' as const,
  checked: selectedColumns.value.includes(column.accessorKey!),
  onUpdateChecked(checked: boolean) {
    const newSelectedColumns = [...selectedColumns.value]
    if (checked) {
      newSelectedColumns.push(column.accessorKey!)
    } else {
      const index = newSelectedColumns.indexOf(column.accessorKey!)
      if (index > -1) {
        newSelectedColumns.splice(index, 1)
      }
    }
    selectedColumns.value = newSelectedColumns
  }
})))
</script>

<template>
  <UDropdownMenu
    v-if="columnOptions.length"
    arrow
    :items="columnItems"
  >
    <UButton
      color="neutral"
      variant="outline"
      icon="i-lucide-settings-2"
    />
  </UDropdownMenu>
</template>



================================================
FILE: app/components/AdminTable/components/filters/DateRange.vue
================================================
<script setup lang="ts">
import { CalendarDate } from '@internationalized/date'
import { useRoute, useRouter } from 'vue-router'

const { name, filterName } = defineProps<{
  name: string
  filterName: string
}>()

const dateRange = defineModel<DateRange>('dateRange', { default: {
  start: undefined,
  end: undefined
} })

const clearDateRange = () => {
  dateRange.value = {
    start: undefined,
    end: undefined
  }
}

const route = useRoute()
const router = useRouter()

if (route.query[filterName]) {
  const { start, end } = JSON.parse(route.query[filterName] as string)
  const starts = start.split('-').map((item: string) => Number(item))
  const ends = end.split('-').map((item: string) => Number(item))
  dateRange.value.start = new CalendarDate(starts[0], starts[1], starts[2])
  dateRange.value.end = new CalendarDate(ends[0], ends[1], ends[2])
}

watch(
  () => dateRange.value,
  (_) => {
    const query = { ...route.query }
    if (dateRange.value.start && dateRange.value.end) {
      const start = dateRange.value.start
      const end = dateRange.value.end
      query[filterName] = JSON.stringify({
        start: `${start.year}-${start.month}-${start.day}`,
        end: `${end.year}-${end.month}-${end.day}`
      })
    } else {
      delete query[filterName]
    }
    router.replace({ query })
  },
  { deep: true }
)
</script>

<template>
  <UPopover
    :content="{
      align: 'start',
      side: 'bottom'
    }"
  >
    <UButton
      color="neutral"
      variant="subtle"
    >
      <UIcon
        v-if="dateRange.start && dateRange.end"
        name="i-lucide-circle-x"
        class="w-4 h-4 mr-1"
        @click.stop="clearDateRange"
      />
      <UIcon
        v-if="!(dateRange.start && dateRange.end)"
        name="i-lucide-calendar"
        class="w-4 h-4 mr-1"
      />
      {{ name }}
      <UBadge
        v-if="dateRange.start && dateRange.end"
        color="neutral"
        variant="outline"
        size="sm"
        class="ml-1"
      >
        {{ dateRange.start }} - {{ dateRange.end }}
      </UBadge>
    </UButton>

    <template #content>
      <UCalendar
        v-model="dateRange"
        class="p-2"
        :number-of-months="2"
        range
      />
    </template>
  </UPopover>
</template>



================================================
FILE: app/components/AdminTable/components/filters/Tabs.vue
================================================
<script setup lang="ts">
import { useRoute, useRouter } from 'vue-router'

const { items, filterName } = defineProps<{
  items: FilterItem[]
  name: string
  filterName: string
}>()

const emit = defineEmits<{
  (e: 'update:filter', value: string): void
}>()

const filter = defineModel<string>('filter', { default: '' })
const filterIndex = ref<string | undefined>(undefined)
const filterValueDict = computed(() => {
  const valueDict: Record<string, string> = {}
  items.forEach((item, index) => {
    valueDict[`key_${index}`] = item.id
    valueDict[`value_${item.id}`] = `${index}`
  })
  return valueDict
})

const route = useRoute()
const router = useRouter()

// Initialize filter from route query
if (route.query[filterName]) {
  const index = filterValueDict.value[`value_${route.query[filterName]}`] || undefined
  if (index != undefined) {
    filter.value = route.query[filterName] as string
    filterIndex.value = index
  }
}

// Watch for changes in filter and update the route query
watch(
  () => filterIndex.value,
  (newFilterIndex) => {
    const query = { ...route.query }
    const newFilter = filterValueDict.value[`key_${newFilterIndex}`] || ''
    if (newFilter) {
      query[filterName] = newFilter
      filter.value = newFilter
    } else {
      delete query[filterName]
      filter.value = ''
    }
    router.replace({ query })
    emit('update:filter', newFilter)
  },
  { deep: true }
)
</script>

<template>
  <UTabs
    v-model="filterIndex"
    variant="link"
    :items="items"
    :ui="{
      root: 'gap-0',
      list: 'bg-elevated rounded-lg p-0 border-0',
      trigger: 'data-[state=active]:text-(--ui-bg) data-[state=active]:bg-primary pl-4 pr-4',
      indicator: 'hidden'
    }"
  >
    <template #trailing="{ item }">
      <UBadge
        v-if="item.count != undefined && item.count > 0"
        color="neutral"
        variant="outline"
        size="sm"
      >
        {{ item.count }}
      </UBadge>
    </template>
  </UTabs>
</template>



================================================
FILE: app/components/AdminTable/components/filters/Checkbox/i18n.json
================================================
{
  "en": {
    "checkboxFilter": {
      "nSelected": "{n} selected"
    }
  },
  "zh-CN": {
    "checkboxFilter": {
      "nSelected": "{n} 个已选择"
    }
  },
  "ja": {
    "checkboxFilter": {
      "nSelected": "{n} 個選択済み"
    }
  },
  "fr": {
    "checkboxFilter": {
      "nSelected": "{n} sélectionné(s)"
    }
  }
}



================================================
FILE: app/components/AdminTable/components/filters/Checkbox/index.vue
================================================
<i18n src="./i18n.json"></i18n>

<script setup lang="ts">
import { useRoute, useRouter } from 'vue-router'

const { items, name, filterName } = defineProps<{
  items: FilterItem[]
  name: string
  filterName: string
}>()

const emit = defineEmits<{
  (e: 'update:filter', value: string[]): void
}>()
const { t } = useI18n()

const filter = defineModel<string[]>('filter', { default: [] })

const route = useRoute()
const router = useRouter()

// Initialize filter from route query
if (route.query[filterName]) {
  filter.value = JSON.parse(route.query[filterName] as string)
}

const selectedItems = computed(() => {
  return items.filter(item => filter.value.includes(item.id))
})

const onUpdateChecked = (checked: string | boolean, item: FilterItem) => {
  if (checked) {
    filter.value.push(item.id)
  } else {
    filter.value.splice(filter.value.indexOf(item.id), 1)
  }
}

// Watch for changes in filter and update the route query
watch(
  () => filter.value,
  (newFilter) => {
    const query = { ...route.query }
    if (newFilter.length) {
      query[filterName] = JSON.stringify(newFilter)
    } else {
      delete query[filterName]
    }
    router.replace({ query })
    emit('update:filter', newFilter)
  },
  { deep: true }
)
</script>

<template>
  <UPopover
    :content="{
      align: 'start',
      side: 'bottom'
    }"
  >
    <UButton
      color="neutral"
      variant="subtle"
    >
      <UIcon
        v-if="selectedItems.length"
        name="i-lucide-circle-x"
        class="w-4 h-4 mr-1"
        @click.stop="filter = []"
      />
      <UIcon
        v-if="!selectedItems.length"
        name="i-lucide-filter"
        class="w-4 h-4 mr-1"
      />
      {{ name }}
      <template v-if="selectedItems.length && selectedItems.length <= 2">
        <UBadge
          v-for="item in selectedItems"
          :key="item.id"
          color="neutral"
          variant="outline"
          size="sm"
          class="ml-1"
        >
          {{ item.label }}
        </UBadge>
      </template>
      <template v-if="selectedItems.length && selectedItems.length > 2">
        <UBadge
          color="neutral"
          variant="outline"
          size="sm"
          class="ml-1"
        >
          {{ t('checkboxFilter.nSelected', { n: selectedItems.length }) }}
        </UBadge>
      </template>
    </UButton>

    <template #content>
      <div class="flex flex-col p-2">
        <div
          v-for="item in items"
          :key="item.id"
          class="flex items-center"
        >
          <UCheckbox
            :key="item.id"
            :model-value="filter.includes(item.id)"
            :ui="{
              wrapper: 'flex-1'
            }"
            class="p-1 flex-1 hover:bg-neutral-100 dark:hover:bg-neutral-800"
            @update:model-value="(e) => onUpdateChecked(e, item)"
          >
            <template #label>
              <div class="flex items-center">
                <span class="flex-1">{{ item.label }}</span>
                <UBadge
                  v-if="item.count != undefined"
                  color="neutral"
                  variant="outline"
                  size="sm"
                  class="ml-2"
                >
                  {{ item.count }}
                </UBadge>
              </div>
            </template>
          </UCheckbox>
        </div>
      </div>
    </template>
  </UPopover>
</template>



================================================
FILE: app/components/AdminTable/components/Pagination/i18n.json
================================================
{
  "en": {
    "pagination": {
      "rowsPerPage": "Rows per page",
      "pageOf": "Page {page} of {totalPage}",
      "selectedRows": "{selected} / {total} row(s) selected",
      "totalRows": "Total row(s): {total}"
    }
  },
  "zh-CN": {
    "pagination": {
      "rowsPerPage": "每页行数",
      "pageOf": "第 {page} 页，共 {totalPage} 页",
      "selectedRows": "已选择 {selected} / {total} 行",
      "totalRows": "共 {total} 行"
    }
  },
  "ja": {
    "pagination": {
      "rowsPerPage": "表示件数",
      "pageOf": "ページ {page} / {totalPage}",
      "selectedRows": "{selected} / {total} 行を選択",
      "totalRows": "合計: {total} 行"
    }
  },
  "fr": {
    "pagination": {
      "rowsPerPage": "Lignes par page",
      "pageOf": "Page {page} sur {totalPage}",
      "selectedRows": "{selected} / {total} ligne(s) sélectionnée(s)",
      "totalRows": "Total: {total} ligne(s)"
    }
  }
}



================================================
FILE: app/components/AdminTable/components/Pagination/index.vue
================================================
<i18n src="./i18n.json"></i18n>

<script setup lang="ts">
const { hidePagination, selectedRowCount, rowCount, total } = defineProps({
  hidePagination: { type: Boolean, default: false },
  canSelect: { type: Boolean, default: false },
  selectedRowCount: { type: Number, default: 0 },
  rowCount: { type: Number, default: 0 },
  total: { type: Number, default: 0 }
})
const { t } = useI18n()
const page = defineModel('page', { default: 1 })
const limit = defineModel('limit', { default: 20 })
const totalPage = computed(() => {
  return Math.ceil(total / limit.value)
})
const sizes = [5, 20, 50, 100]
</script>

<template>
  <div class="w-full flex flex-col sm:flex-row items-center justify-between py-2 text-sm text-muted border-t border-accented">
    <div class="px-4">
      <span
        v-if="canSelect"
        class="mr-4"
      >
        {{ t('pagination.selectedRows', { selected: selectedRowCount, total: rowCount }) }}
      </span>
      <span>{{ t('pagination.totalRows', { total }) }}</span>
    </div>
    <div
      v-if="!hidePagination"
      class="flex items-center"
    >
      <span class="ml-4 mr-1 text-sm hidden sm:block">{{ t('pagination.rowsPerPage') }}</span>
      <USelect
        v-model="limit"
        :items="sizes"
      />
      <span class="ml-4 mr-4 text-sm">{{ t('pagination.pageOf', { page, totalPage }) }}</span>
      <UPagination
        v-model:page="page"
        :items-per-page="limit"
        :total="total"
        show-edges
      />
    </div>
  </div>
</template>



================================================
FILE: app/components/AdminTable/components/SortControl/i18n.json
================================================
{
  "en": {
    "sortControl": {
      "sort": "Sort",
      "addSort": "Add sort",
      "resetSorting": "Reset sorting",
      "asc": "Asc",
      "desc": "Desc",
      "sortBy": "Sort By",
      "noSorting": "No sorting applied",
      "addSortingHint": "Add sorting to organize your rows."
    }
  },
  "zh-CN": {
    "sortControl": {
      "sort": "排序",
      "addSort": "添加排序",
      "resetSorting": "重置排序",
      "asc": "升序",
      "desc": "降序",
      "sortBy": "排序方式",
      "noSorting": "未应用排序",
      "addSortingHint": "添加排序以组织您的行。"
    }
  },
  "ja": {
    "sortControl": {
      "sort": "並べ替え",
      "addSort": "並べ替えを追加",
      "resetSorting": "並べ替えをリセット",
      "asc": "昇順",
      "desc": "降順",
      "sortBy": "並べ替え基準",
      "noSorting": "並べ替えが適用されていません",
      "addSortingHint": "行を整理するために並べ替えを追加してください。"
    }
  },
  "fr": {
    "sortControl": {
      "sort": "Trier",
      "addSort": "Ajouter un tri",
      "resetSorting": "Réinitialiser le tri",
      "asc": "Ascendant",
      "desc": "Descendant",
      "sortBy": "Trier par",
      "noSorting": "Aucun tri appliqué",
      "addSortingHint": "Ajoutez un tri pour organiser vos lignes."
    }
  }
}



================================================
FILE: app/components/AdminTable/components/SortControl/index.vue
================================================
<i18n src="./i18n.json"></i18n>

<script setup lang="ts" generic="T">
import SortableContent from './SortableContent.vue'

const { columns } = defineProps<{
  columns: AdminTableColumn<T>[]
}>()

const sortOptions = defineModel<SortOption[]>('sortOptions', { default: [] })

const { t } = useI18n()
</script>

<template>
  <UPopover
    arrow
    :content="{ align: 'end', side: 'bottom' }"
  >
    <UButton
      color="neutral"
      variant="outline"
      icon="lucide-arrow-down-up"
    >
      {{ sortOptions.length ? t('sortControl.sort') : '' }}
      <UBadge
        v-if="sortOptions.length"
        color="neutral"
        variant="outline"
        size="sm"
      >
        {{ sortOptions.length }}
      </UBadge>
    </UButton>
    <template #content>
      <SortableContent
        v-model:sort-options="sortOptions"
        :columns="columns"
        :t="t"
      />
    </template>
  </UPopover>
</template>



================================================
FILE: app/components/AdminTable/components/SortControl/SortableContent.vue
================================================
<script setup lang="ts" generic="T">
import { useSortable } from '@vueuse/integrations/useSortable'

const { columns, t } = defineProps<{
  columns: AdminTableColumn<T>[]
  t: TranFunction
}>()

const dragEl = useTemplateRef<HTMLElement>('dragEl')
const sortOptions = defineModel<SortOption[]>('sortOptions', { default: [] })

useSortable(dragEl, sortOptions, {
  handle: '.drag-handle'
})

const columnsOptions = computed(() => {
  return columns.filter(column => column.header && column.accessorKey).map(column => ({
    label: column.header as string,
    value: column.accessorKey as string
  }))
})
const existingFields = computed(() => {
  return sortOptions.value.map(sort => sort.field)
})

const availableColumns = computed(() => {
  return columnsOptions.value.filter(option => !existingFields.value.includes(option.value))
})

const findSelectedColumn = (field: string) => {
  if (!field) {
    return []
  }
  return columnsOptions.value.filter(option => option.value === field)
}

const addSort = () => {
  if (availableColumns.value.length === 0) {
    return
  }
  sortOptions.value = [
    ...sortOptions.value,
    { field: availableColumns.value[0]!.value, order: 'asc' }
  ]
}
const removeSort = (index: number) => {
  const updatedSortOptions = [...sortOptions.value]
  updatedSortOptions.splice(index, 1)
  sortOptions.value = updatedSortOptions
}

const resetSorting = () => {
  sortOptions.value = []
}
</script>

<template>
  <div class="p-4 rounded bg-white dark:bg-neutral-800 shadow-md w-80">
    <div class="text-neutral-500 dark:text-neutral-400 text-sm mb-2">
      <span class="font-bold">
        {{ sortOptions.length === 0 ? t('sortControl.noSorting') : t('sortControl.sortBy') }}</span>
      <template v-if="sortOptions.length === 0">
        <br>
        {{ t('sortControl.addSortingHint') }}
      </template>
    </div>
    <div ref="dragEl">
      <div
        v-for="(sort, index) in sortOptions"
        :key="index"
        class="flex items-center mb-2"
      >
        <USelect
          v-model="sort.field"
          :items="[...findSelectedColumn(sort.field), ...availableColumns]"
          class="flex-1 mr-2"
        />
        <USelect
          v-model="sort.order"
          :items="[{ label: t('sortControl.asc'), value: 'asc' }, { label: t('sortControl.desc'), value: 'desc' }]"
          class="w-24 mr-2"
        />
        <UButton
          icon="lucide-trash"
          color="neutral"
          variant="outline"
          class="mr-2"
          @click="removeSort(index)"
        />
        <UButton
          icon="lucide-grip-vertical"
          color="neutral"
          variant="outline"
          class="drag-handle"
        />
      </div>
    </div>
    <div class="flex mt-4 gap-x-2">
      <UButton
        color="neutral"
        variant="solid"
        @click="addSort"
      >
        {{ t('sortControl.addSort') }}
      </UButton>
      <UButton
        v-if="sortOptions.length > 0"
        color="neutral"
        variant="outline"
        @click="resetSorting"
      >
        {{ t('sortControl.resetSorting') }}
      </UButton>
    </div>
  </div>
</template>



================================================
FILE: app/components/AdminTable/composables/useColumnControl.ts
================================================
import type { ShallowRef } from 'vue'
import type { UTableInstance } from '../types'

export default function useColumnControl<T>(columns: AdminTableColumn<T>[], tableRef: ShallowRef<UTableInstance | null>) {
  const defaultSelectedColumns = columns
    .map(column => (column.accessorKey || column.id)!)
  const selectedColumns = ref(defaultSelectedColumns)

  watchEffect(() => {
    for (const column of columns) {
      const columnKey = (column.accessorKey || column.id)!
      if (selectedColumns.value.includes(columnKey)) {
        tableRef.value?.tableApi?.getColumn(columnKey)?.toggleVisibility(true)
      }
      else {
        tableRef.value?.tableApi?.getColumn(columnKey)?.toggleVisibility(false)
      }
    }
  })
  return {
    selectedColumns
  }
}



================================================
FILE: app/components/AdminTable/composables/useSelectControl.ts
================================================
import type { RowData } from '@tanstack/vue-table'
import type { ShallowRef } from 'vue'
import type { UTableInstance } from '../types'

export default function useSelectControl<T extends RowData>(tableRef: ShallowRef<UTableInstance | null>, rowId?: string) {
  const selectColumnId = 'admin-table-select'
  const getRowId = (originalRow: T, index: number) => {
    if (rowId) {
      return `${(originalRow as Record<string, any>)[rowId] || index}`
    } else {
      return `${index}`
    }
  }
  const selectedRowCount = computed(() => {
    return tableRef.value?.tableApi?.getFilteredSelectedRowModel().rows.length || 0
  })
  const rowCount = computed(() => {
    return tableRef.value?.tableApi?.getFilteredRowModel().rows.length || 0
  })
  return {
    selectColumnId,
    getRowId,
    selectedRowCount,
    rowCount
  }
}



================================================
FILE: app/components/ColorModeToggler/i18n.json
================================================
{
  "en": {
    "colorModeToggler": {
      "ariaLabel": "Change Color Mode"
    }
  },
  "zh-CN": {
    "colorModeToggler": {
      "ariaLabel": "切换颜色模式"
    }
  },
  "ja": {
    "colorModeToggler": {
      "ariaLabel": "カラーモードを変更"
    }
  },
  "fr": {
    "colorModeToggler": {
      "ariaLabel": "Changer le mode de couleur"
    }
  }
}



================================================
FILE: app/components/ColorModeToggler/index.vue
================================================
<i18n src="./i18n.json"></i18n>

<script setup lang="ts">
const colorMode = useColorMode()
const { t } = useI18n()

const toggleColorMode = () => {
  colorMode.preference = colorMode.value === 'light' ? 'dark' : 'light'
}
</script>

<template>
  <UButton
    :icon="colorMode.value === 'light' ? 'i-lucide-moon' : 'i-lucide-sun'"
    color="neutral"
    variant="ghost"
    :aria-label="t('colorModeToggler.ariaLabel')"
    @click="toggleColorMode"
  />
</template>



================================================
FILE: app/components/LocaleToggler/i18n.json
================================================
{
  "en": {
    "localeToggler": {
      "ariaLabel": "Change language"
    }
  },
  "zh-CN": {
    "localeToggler": {
      "ariaLabel": "切换语言"
    }
  },
  "ja": {
    "localeToggler": {
      "ariaLabel": "言語を変更"
    }
  },
  "fr": {
    "localeToggler": {
      "ariaLabel": "Changer de langue"
    }
  }
}



================================================
FILE: app/components/LocaleToggler/index.vue
================================================
<i18n src="./i18n.json"></i18n>

<script setup lang="ts">
const { locale, setLocale, locales } = useI18n()
const { t } = useI18n()
const localeItems = computed(() => {
  return locales.value.map(item => ({
    label: item.name,
    type: 'checkbox' as const,
    checked: locale.value === item.code,
    onUpdateChecked: async (checked: boolean) => {
      if (checked) {
        await setLocale(item.code)
      }
    }
  }))
})
</script>

<template>
  <UDropdownMenu :items="localeItems">
    <UButton
      icon="i-lucide-languages"
      color="neutral"
      variant="ghost"
      class="w-8 h-8"
      :aria-label="t('localeToggler.ariaLabel')"
    />
  </UDropdownMenu>
</template>



================================================
FILE: app/composables/useAdminTable.ts
================================================
import type { AdminTable } from '#components'
import type { ComponentExposed } from 'vue-component-type-helpers'

export function useAdminTable(refName: string = 'table') {
  const adminTableRef = useTemplateRef<ComponentExposed<typeof AdminTable>>(refName)
  const refresh = () => {
    adminTableRef.value?.fetchTableData()
  }
  return {
    refresh
  }
}



================================================
FILE: app/composables/useAuth.ts
================================================
import type { Subscription } from '@better-auth/stripe'
import type { CustomerState } from '@polar-sh/sdk/models/components/customerstate.js'
import type {
  ClientOptions,
  InferSessionFromClient
} from 'better-auth/client'
import type { RouteLocationRaw } from 'vue-router'
import { stripeClient } from '@better-auth/stripe/client'
import { polarClient } from '@polar-sh/better-auth'
import { adminClient, inferAdditionalFields } from 'better-auth/client/plugins'
import { createAuthClient } from 'better-auth/vue'

export function useAuth() {
  const url = useRequestURL()
  const headers = import.meta.server ? useRequestHeaders() : undefined
  const runtimeConfig = useRuntimeConfig()
  const payment = runtimeConfig.public.payment as 'stripe' | 'polar'
  const client = createAuthClient({
    baseURL: url.origin,
    fetchOptions: {
      headers
    },
    plugins: [
      inferAdditionalFields({
        user: {
          polarCustomerId: {
            type: 'string'
          }
        }
      }),
      adminClient(),
      polarClient(),
      stripeClient({
        subscription: true
      })
    ]
  })

  const session = useState<InferSessionFromClient<ClientOptions> | null>('auth:session', () => null)
  const user = useState<User | null>('auth:user', () => null)
  const subscriptions = useState<Subscription[]>('auth:subscriptions', () => [])
  const polarState = useState<CustomerState | null>('auth:polarState', () => null)
  const sessionFetching = import.meta.server ? ref(false) : useState('auth:sessionFetching', () => false)

  const fetchSession = async () => {
    if (sessionFetching.value) {
      return
    }
    sessionFetching.value = true
    const { data } = await client.useSession(useFetch)
    session.value = data.value?.session || null

    const userDefaults = {
      image: null,
      role: null,
      banReason: null,
      banned: null,
      banExpires: null,
      stripeCustomerId: null
    }
    user.value = data.value?.user
      ? Object.assign({}, userDefaults, data.value.user)
      : null
    subscriptions.value = []
    if (user.value) {
      if (payment == 'stripe') {
        const { data: subscriptionData } = await client.subscription.list()
        subscriptions.value = subscriptionData || []
      } else if (payment == 'polar') {
        const { data: customerState } = await client.customer.state()
        polarState.value = customerState
      }
    }
    sessionFetching.value = false
    return data
  }

  if (import.meta.client) {
    client.$store.listen('$sessionSignal', async (signal) => {
      if (!signal)
        return
      await fetchSession()
    })
  }

  return {
    session,
    user,
    subscription: client.subscription,
    subscriptions,
    loggedIn: computed(() => !!session.value),
    activeStripeSubscription: computed(() => {
      return subscriptions.value.find(
        sub => sub.status === 'active' || sub.status === 'trialing'
      )
    }),
    activePolarSubscriptions: computed(() => {
      return polarState.value?.activeSubscriptions
    }),
    signIn: client.signIn,
    signUp: client.signUp,
    forgetPassword: client.forgetPassword,
    resetPassword: client.resetPassword,
    sendVerificationEmail: client.sendVerificationEmail,
    errorCodes: client.$ERROR_CODES,
    async signOut({ redirectTo }: { redirectTo?: RouteLocationRaw } = {}) {
      await client.signOut({
        fetchOptions: {
          onSuccess: async () => {
            session.value = null
            user.value = null
            if (redirectTo) {
              await navigateTo(redirectTo)
            }
          }
        }
      })
    },
    fetchSession,
    payment,
    client
  }
}



================================================
FILE: app/composables/useCustomFetch.ts
================================================
import type { UseFetchOptions } from 'nuxt/app'

export function useCustomFetch<T>(
  url: string | Request | Ref<string | Request> | (() => string | Request),
  options: UseFetchOptions<T> = {}
) {
  return {
    ...useFetch(url, {
      ...options,
      $fetch: useNuxtApp().$customFetch
    })
  }
}



================================================
FILE: app/i18n/global.json
================================================
{
  "en": {
    "global": {
      "appName": "NuxSaaS",
      "nav": {
        "admin": "Admin",
        "features": "Features",
        "pricing": "Pricing",
        "docs": "Documentation"
      },
      "auth": {
        "signIn": "Sign In",
        "signOut": "Sign Out",
        "profile": "Profile"
      },
      "page": {
        "actions": "Actions",
        "create": "Create",
        "edit": "Edit",
        "save": "Save",
        "delete": "Delete",
        "cancel": "Cancel",
        "name": "Name",
        "status": "Status",
        "createdAt": "Created At",
        "all": "All"
      }
    }
  },
  "zh-CN": {
    "global": {
      "appName": "NuxSaaS",
      "nav": {
        "admin": "管理后台",
        "features": "功能特性",
        "pricing": "定价方案",
        "docs": "文档"
      },
      "auth": {
        "signIn": "登录",
        "signOut": "退出",
        "profile": "个人资料"
      },
      "page": {
        "actions": "操作",
        "create": "创建",
        "edit": "编辑",
        "save": "保存",
        "delete": "删除",
        "cancel": "取消",
        "name": "名称",
        "status": "状态",
        "createdAt": "创建时间",
        "all": "全部"
      }
    }
  },
  "ja": {
    "global": {
      "appName": "NuxSaaS",
      "nav": {
        "admin": "管理画面",
        "features": "機能",
        "pricing": "料金",
        "docs": "ドキュメント"
      },
      "auth": {
        "signIn": "ログイン",
        "signOut": "ログアウト",
        "profile": "プロフィール"
      },
      "page": {
        "actions": "アクション",
        "create": "作成",
        "edit": "編集",
        "save": "保存",
        "delete": "削除",
        "cancel": "キャンセル",
        "name": "名前",
        "status": "状態",
        "createdAt": "作成日時",
        "all": "すべて"
      }
    }
  },
  "fr": {
    "global": {
      "appName": "NuxSaaS",
      "nav": {
        "admin": "Administration",
        "features": "Fonctionnalités",
        "pricing": "Tarification",
        "docs": "Documentation"
      },
      "auth": {
        "signIn": "Connexion",
        "signOut": "Déconnexion",
        "profile": "Profil"
      },
      "page": {
        "actions": "Actions",
        "create": "Créer",
        "edit": "Modifier",
        "save": "Enregistrer",
        "delete": "Supprimer",
        "cancel": "Annuler",
        "name": "Nom",
        "status": "Statut",
        "createdAt": "Créé le",
        "all": "Tout"
      }
    }
  }
}



================================================
FILE: app/i18n/i18n.config.ts
================================================
import globalMessage from './global.json'

export default defineI18nConfig(() => ({
  legacy: false,
  locale: 'en',
  fallbackWarn: false,
  missingWarn: false,
  messages: globalMessage
}))



================================================
FILE: app/layouts/admin.vue
================================================
<i18n src="./menu/i18n.json"></i18n>

<script setup lang="ts">
import SearchPalette from './components/SearchPalette.vue'
import { getMenus } from './menu'

const { user, signOut } = useAuth()

const router = useRouter()
const route = useRoute()
const { t } = useI18n()
const localePath = useLocalePath()
const isCollapsed = ref(false)
const runtimeConfig = useRuntimeConfig()

defineShortcuts({
  'g-1': () => router.push(localePath('/admin/dashboard')),
  'g-2': () => router.push(localePath('/admin/user'))
})
const pathNameItemMap: StringDict<NavigationMenuItem> = {}
const pathNameParentMap: StringDict<NavigationMenuItem | undefined> = {}

const menus = getMenus(t, localePath, runtimeConfig.public.appRepo)
const menuIterator = (menus: NavigationMenuItem[], parent?: NavigationMenuItem) => {
  for (const menu of menus) {
    const to = `${menu.to}`
    pathNameItemMap[to] = menu!
    pathNameParentMap[to] = parent
    if (menu.to == route.path) {
      if (pathNameParentMap[to]) {
        pathNameParentMap[to].defaultOpen = true
      }
    }
    if (menu.children) {
      menuIterator(menu.children, menu)
    }
  }
}
menus.forEach((group) => {
  menuIterator(group)
})

const clickSignOut = () => {
  signOut({ redirectTo: localePath('/signin') })
}
</script>

<template>
  <div>
    <aside
      class="fixed top-0 left-0 transition-all duration-300 hidden sm:block"
      :class="[isCollapsed ? 'w-15' : 'w-64']"
    >
      <div class="h-screen flex flex-col px-3 py-4 bg-gray-100 dark:bg-gray-800">
        <a
          v-if="!isCollapsed"
          class="flex items-center ps-2.5"
        >
          <Logo class="h-6 w-6" />
          <span
            class="self-center ml-2 text-xl font-semibold whitespace-nowrap dark:text-white"
          >
            {{ t('global.appName') }}
          </span>
        </a>
        <Logo
          v-if="isCollapsed"
          class="h-6 w-6 ml-1"
        />
        <div
          class="flex mb-2 mt-3"
          :class="{ 'pl-2 pr-2': !isCollapsed }"
        >
          <SearchPalette
            :collapsed="isCollapsed"
            :t="t"
          />
        </div>
        <UNavigationMenu
          :items="menus"
          :collapsed="isCollapsed"
          orientation="vertical"
          class="data-[orientation=vertical]:w-full flex-1 overflow-y-auto"
        />
        <div class="flex flex-col pl-1 pr-2">
          <USeparator />
          <UTooltip
            :ui="{ content: 'w-54 flex flex-col h-auto p-0 gap-0' }"
            :delay-duration="100"
            :disable-closing-trigger="true"
          >
            <template #content>
              <UButton
                icon="i-lucide-log-out"
                size="sm"
                color="neutral"
                variant="link"
                class="w-full p-[10px]"
                @click="clickSignOut"
              >
                {{ t('global.auth.signOut') }}
              </UButton>
            </template>
            <div
              class="w-full flex items-center justify-between mt-2 pt-2 pb-2"
              :class="{ 'pl-2 pr-2': !isCollapsed }"
            >
              <div class="flex items-center">
                <UAvatar
                  :src="user?.image || undefined"
                  size="xs"
                  class="border border-gray-300 dark:border-gray-700"
                />
                <span
                  v-if="!isCollapsed"
                  class="text-xs ml-2"
                >
                  {{ user?.name }}
                </span>
              </div>
              <UIcon
                v-if="!isCollapsed"
                name="i-lucide-ellipsis-vertical"
              />
            </div>
          </UTooltip>
        </div>
      </div>
    </aside>
    <div
      class="p-2 h-screen bg-white dark:bg-gray-900 transition-all duration-300 overflow-hidden flex flex-col"
      :class="[isCollapsed ? 'sm:ml-15' : 'sm:ml-64']"
    >
      <FlexThreeColumn class="mb-2 flex-none">
        <template #left>
          <UDrawer
            class="sm:hidden"
            direction="left"
            as="aside"
            :handle="false"
          >
            <UButton
              icon="i-lucide-menu"
              class="w-8 h-8"
              color="neutral"
              variant="ghost"
            />
            <template #content>
              <div class="w-[60vw] p-4">
                <UNavigationMenu
                  orientation="vertical"
                  :items="menus"
                  class="data-[orientation=vertical]:w-full"
                />
              </div>
            </template>
          </UDrawer>
          <UButton
            :icon="isCollapsed ? 'i-lucide-panel-left-open' : 'i-lucide-panel-left-close'"
            class="w-8 h-8 hidden sm:block"
            color="neutral"
            variant="ghost"
            @click="isCollapsed = !isCollapsed"
          />
          <title>{{ pathNameItemMap[$route.path]?.label }}</title>
          <h1>{{ pathNameItemMap[$route.path]?.label }} </h1>
          <slot name="navLeft" />
        </template>
        <template #middle>
          <slot name="navMiddle" />
        </template>
        <template #right>
          <slot name="navRight" />
          <LocaleToggler />
          <ClientOnly>
            <ColorModeToggler />
          </ClientOnly>
        </template>
      </FlexThreeColumn>
      <div class="p-2 border-2 border-gray-200 border-dashed rounded-lg dark:border-gray-700 flex-1 overflow-auto">
        <slot />
      </div>
    </div>
  </div>
</template>



================================================
FILE: app/layouts/default.vue
================================================
<script lang="ts" setup>
import AppFooter from './components/AppFooter.vue'
import AppNavbar from './components/AppNavbar.vue'

const i18nHead = useLocaleHead()
useHead(() => ({
  link: [...(i18nHead.value.link || [])]
}))
</script>

<template>
  <div class="min-h-screen flex flex-col items-center relative">
    <AppNavbar>
      <template #center>
        <slot name="nav-center" />
      </template>
      <template #right>
        <slot name="nav-right" />
      </template>
    </AppNavbar>
    <div class="flex flex-1 pt-16 w-full sm:w-auto">
      <slot />
    </div>
    <AppFooter />
  </div>
</template>



================================================
FILE: app/layouts/components/AppFooter.vue
================================================
<script lang="ts" setup>
const { t } = useI18n()
const runtimeConfig = useRuntimeConfig()
</script>

<template>
  <footer class="w-full h-26 sm:h-16 border-t border-gray-200 dark:border-gray-800 py-4 z-1">
    <div class="container mx-auto px-4">
      <div class="flex flex-col md:flex-row justify-between items-center gap-4">
        <div class="flex items-center space-x-2">
          <UIcon name="i-lucide-code" />
          <span>{{ t('global.appName') }}</span>
          <USeparator
            orientation="vertical"
            class="hidden md:block"
          />
          <span class="text-sm text-gray-500 dark:text-gray-400">
            © {{ new Date().getFullYear() }} All rights reserved
          </span>
        </div>

        <div class="flex items-center space-x-4">
          <LocaleToggler />
          <ClientOnly>
            <ColorModeToggler />
          </ClientOnly>
          <UButton
            icon="i-simple-icons-github"
            variant="ghost"
            color="neutral"
            :href="runtimeConfig.public.appRepo"
            target="_blank"
            aria-label="Github"
            rel="noopener noreferrer"
          />
        </div>
      </div>
    </div>
  </footer>
</template>



================================================
FILE: app/layouts/components/AppNavbar.vue
================================================
<script lang="ts" setup>
const { t } = useI18n()
const localePath = useLocalePath()
</script>

<template>
  <!-- Navigation -->
  <nav class="fixed h-16 top-0 left-0 right-0 z-50 bg-white/70 dark:bg-gray-900/70 backdrop-blur-md border-b border-gray-200 dark:border-gray-800">
    <UContainer class="flex h-full items-center justify-between">
      <NuxtLink
        :to="localePath('/')"
        class="flex items-center gap-2"
      >
        <span class="font-bold text-xl flex items-center">
          <Logo class="w-6 h-6 mr-1" />
          {{ t('global.appName') }}
        </span>
      </NuxtLink>

      <slot name="center" />
      <slot name="right" />
    </UContainer>
  </nav>
</template>



================================================
FILE: app/layouts/components/SearchPalette.vue
================================================
<script setup lang="ts">
const { t } = defineProps<{
  t: TranFunction
}>()
const router = useRouter()
const localePath = useLocalePath()
const collapsed = defineModel('collapsed', { default: false })

const groups = ref([
  {
    id: 'Routes',
    label: t('menu.navigation'),
    items: [
      {
        label: t('menu.dashboard'),
        icon: 'i-lucide-layout-dashboard',
        to: localePath('/admin/dashboard'),
        kbds: [
          'G',
          '1'
        ]
      },
      {
        label: t('menu.users'),
        icon: 'i-lucide-users',
        to: localePath('/admin/user'),
        kbds: [
          'G',
          '2'
        ]
      }
    ]
  }
])

const value = ref({})
const isOpen = ref(false)

defineShortcuts({
  shift_g: {
    usingInput: true,
    handler: () => {
      isOpen.value = !isOpen.value
    }
  },
  escape: {
    usingInput: true,
    handler: () => { isOpen.value = false }
  }
})

const onClosePalette = (value: boolean) => {
  if (!value) {
    isOpen.value = false
  }
}

function onSelectPalette(item: any) {
  if (item.onSelect) {
    item.onSelect()
  } else if (item.to) {
    if (typeof item.to === 'string' && (item.target === '_blank' || item.to.startsWith('http'))) {
      window.open(item.to, item.target || '_blank')
    } else {
      router.push(item.to)
    }
  }
  onClosePalette(false)
}
</script>

<template>
  <UModal v-model:open="isOpen">
    <UButton
      :class="{ 'w-full': !collapsed }"
      size="sm"
      icon="i-lucide-search"
      color="neutral"
      variant="outline"
      @click="isOpen = true"
    >
      <span
        v-if="!collapsed"
        class="w-full text-left"
      >
        {{ `${t('menu.search')}...` }}
      </span>
      <template
        v-if="!collapsed"
        #trailing
      >
        <UKbd value="shift" />
        <UKbd value="G" />
      </template>
    </UButton>
    <template #content>
      <UCommandPalette
        v-model="value"
        close
        :groups="groups"
        :placeholder="`${t('menu.search')}...`"
        class="flex-1"
        @update:open="onClosePalette"
        @update:model-value="onSelectPalette"
      />
    </template>
  </UModal>
</template>



================================================
FILE: app/layouts/menu/i18n.json
================================================
{
  "en": {
    "menu": {
      "navigation": "Navigation",
      "search": "Search",
      "dashboard": "Dashboard",
      "users": "Users",
      "subscriptions": "Subscriptions",
      "maintenance": "Maintenance",
      "dbStats": "Database Status",
      "home": "Home",
      "auditLog": "Audit Log",
      "migration": "Data Migration"
    }
  },
  "zh-CN": {
    "menu": {
      "navigation": "导航",
      "search": "搜索",
      "dashboard": "仪表板",
      "users": "用户",
      "subscriptions": "订阅管理",
      "maintenance": "系统维护",
      "dbStats": "数据库状态",
      "home": "首页",
      "auditLog": "审计日志",
      "migration": "数据迁移"
    }
  },
  "ja": {
    "menu": {
      "navigation": "ナビゲーション",
      "search": "検索",
      "dashboard": "ダッシュボード",
      "users": "ユーザー",
      "subscriptions": "サブスクリプション",
      "maintenance": "メンテナンス",
      "dbStats": "データベース状態",
      "home": "ホーム",
      "auditLog": "監査ログ",
      "migration": "データ移行"
    }
  },
  "fr": {
    "menu": {
      "navigation": "Navigation",
      "search": "Rechercher",
      "dashboard": "Tableau de bord",
      "users": "Utilisateurs",
      "subscriptions": "Abonnements",
      "maintenance": "Maintenance",
      "dbStats": "État de la base de données",
      "home": "Accueil",
      "auditLog": "Journal d'audit",
      "migration": "Migration de Données"
    }
  }
}



================================================
FILE: app/layouts/menu/index.ts
================================================
import type { LocalePathFunction } from '#i18n'

export const getMenus = (t: TranFunction, localePath: LocalePathFunction, appRepo: string): NavigationMenuItem[][] => {
  return [
    [
      {
        label: t('menu.dashboard'),
        icon: 'i-lucide-layout-dashboard',
        to: localePath('/admin/dashboard')
      },
      {
        label: t('menu.users'),
        icon: 'i-lucide-users',
        to: localePath('/admin/user')
      },
      {
        label: t('menu.subscriptions'),
        icon: 'i-lucide-credit-card',
        to: localePath('/admin/subscription')
      },
      {
        label: t('menu.maintenance'),
        icon: 'i-lucide-wrench',
        children: [
          {
            label: t('menu.auditLog'),
            icon: 'i-lucide-history',
            to: localePath('/admin/maintenance/audit-log')
          },
          {
            label: t('menu.dbStats'),
            icon: 'i-lucide-database',
            to: localePath('/admin/maintenance/db-stats')
          },
          {
            label: t('menu.migration'),
            icon: 'i-lucide-database-zap',
            to: localePath('/admin/maintenance/migration')
          }
        ]
      }
    ],
    [
      {
        label: t('menu.home'),
        icon: 'i-lucide-home',
        to: localePath('/')
      },
      {
        label: 'GitHub',
        icon: 'i-lucide-github',
        to: appRepo,
        target: '_blank'
      }
    ]
  ]
}



================================================
FILE: app/middleware/auth.global.ts
================================================
import { defu } from 'defu'

type MiddlewareOptions = false | {
  /**
   * Only apply auth middleware to guest or user
   */
  only?: 'guest' | 'user'
  /**
   * Redirect authenticated user to this route
   */
  redirectUserTo?: string
  /**
   * Redirect guest to this route
   */
  redirectGuestTo?: string
}

declare module '#app' {
  interface PageMeta {
    auth?: MiddlewareOptions
  }
}

declare module 'vue-router' {
  interface RouteMeta {
    auth?: MiddlewareOptions
  }
}

export default defineNuxtRouteMiddleware(async (to) => {
  // If auth is disabled, skip middleware
  if (to.meta?.auth === false) {
    return
  }
  const { loggedIn, user, fetchSession } = useAuth()
  const redirectOptions = useRuntimeConfig().public.auth
  const { only, redirectUserTo, redirectGuestTo } = defu(to.meta?.auth, redirectOptions)

  await fetchSession()

  const localePath = useLocalePath()

  if (only === 'guest') {
    if (loggedIn.value) {
      // Guest-only routes: redirect authenticated users to specified path
      // Avoid infinite redirect
      if (to.path === localePath(redirectUserTo)) {
        return
      }
      return navigateTo(localePath(redirectUserTo))
    } else {
      // Allow guest access to this route
      return
    }
  }

  // If not authenticated, redirect to home
  if (!loggedIn.value) {
    // Avoid infinite redirect
    if (to.path === localePath(redirectGuestTo)) {
      return
    }
    return navigateTo(localePath(`${redirectGuestTo}?redirect=${to.fullPath}`))
  }

  // Admin Pages
  const routeBaseName = useRouteBaseName()
  const routeName = routeBaseName(to)
  if (routeName?.startsWith('admin') && user.value?.role != 'admin') {
    return navigateTo(localePath('/403'))
  }
  if (routeName == 'admin') {
    return navigateTo(localePath('/admin/dashboard'))
  }
})



================================================
FILE: app/pages/admin.vue
================================================
<script setup lang="ts">
definePageMeta({
  layout: false
})
</script>

<template>
  <NuxtPage />
</template>



================================================
FILE: app/pages/index.json
================================================
{
  "en": {
    "home": {
      "slogan": "Nuxt.js Full-Stack SaaS Starter Kit - Free & Open Source",
      "getStarted": "Get Started",
      "viewOnGithub": "View on GitHub",
      "features": {
        "title": "Solid Foundation for Your SaaS Success",
        "categories": {
          "foundation": "Foundation",
          "integration": "Integration",
          "admin": "Admin",
          "experience": "Experience",
          "developer": "Developer"
        },
        "items": {
          "modernTechStack": {
            "title": "Modern Tech Stack",
            "description": "Built with Nuxt, ready for Nuxt v4, TypeScript and Vue 3 Composition API"
          },
          "secureAuth": {
            "title": "Secure Auth",
            "description": "A robust authentication system powered by Better Auth, providing OAuth2 social logins (Google, GitHub, etc.), sign-in/up, and email-based password reset capabilities."
          },
          "enterpriseDatabase": {
            "title": "Enterprise Database",
            "description": "PostgreSQL with Drizzle ORM for type-safe operations"
          },
          "emailIntegration": {
            "title": "Email Integration",
            "description": "Built-in Resend integration for transactional emails"
          },
          "paymentReady": {
            "title": "Payment Ready",
            "description": "Stripe/Polar integration for subscription management"
          },
          "noVendorLockIn": {
            "title": "No Vendor Lock-in",
            "description": "Modular architecture with swappable components"
          },
          "dashboard": {
            "title": "Dashboard",
            "description": "A powerful admin dashboard with beautiful charts"
          },
          "advancedTables": {
            "title": "Advanced Tables",
            "description": "Notion/Airtable like advanced filtering, sorting, and pagination, and built-in generic list api out of the box"
          },
          "userSubscriptionManagement": {
            "title": "User/Subscription Management",
            "description": "Ready to use User/Subscription management page"
          },
          "modernUIDesign": {
            "title": "Modern UI Design",
            "description": "Beautiful components with Nuxt UI and TailwindCSS"
          },
          "i18nReady": {
            "title": "I18n Ready",
            "description": "Built-in support for multiple languages"
          },
          "responsiveLayout": {
            "title": "Responsive Layout",
            "description": "Optimized for all devices and screen sizes"
          },
          "developerFriendly": {
            "title": "Developer Friendly",
            "description": "ESLint + TypeScript for better development"
          },
          "quickSetup": {
            "title": "Quick Setup",
            "description": "Start developing in minutes"
          },
          "customizable": {
            "title": "Customizable",
            "description": "Easily extend and customize components"
          }
        }
      },
      "screenshots": {
        "title": "Screenshots",
        "dashboard": "Dashboard",
        "users": "User Management",
        "pricing": "Pricing Plans",
        "subscription": "Subscription Management",
        "signin": "Sign In"
      }
    }
  },
  "zh-CN": {
    "home": {
      "slogan": "Nuxt.js 全栈 SaaS 起步工具包 - 免费开源",
      "getStarted": "开始使用",
      "viewOnGithub": "在 GitHub 上查看",
      "features": {
        "title": "为您的 SaaS 成功打造坚实基础",
        "categories": {
          "foundation": "基础架构",
          "integration": "集成功能",
          "admin": "管理功能",
          "experience": "用户体验",
          "developer": "开发者友好"
        },
        "items": {
          "modernTechStack": {
            "title": "现代技术栈",
            "description": "使用 Nuxt 构建，支持 Nuxt v4、TypeScript 和 Vue 3 组合式 API"
          },
          "secureAuth": {
            "title": "安全认证",
            "description": "由 Better Auth 提供支持的强大身份验证系统，支持 OAuth2 社交登录（Google、GitHub 等）、登录/注册和基于邮件的密码重置功能。"
          },
          "enterpriseDatabase": {
            "title": "企业级数据库",
            "description": "使用 PostgreSQL 和 Drizzle ORM 实现类型安全的数据操作"
          },
          "emailIntegration": {
            "title": "邮件集成",
            "description": "内置 Resend 集成用于发送交易邮件"
          },
          "paymentReady": {
            "title": "支付就绪",
            "description": "集成 Stripe/Polar 实现订阅管理"
          },
          "noVendorLockIn": {
            "title": "无供应商锁定",
            "description": "模块化架构，组件可互换"
          },
          "dashboard": {
            "title": "仪表盘",
            "description": "功能强大的管理仪表盘，配备精美图表"
          },
          "advancedTables": {
            "title": "高级表格",
            "description": "类似 Notion/Airtable 的高级筛选、排序和分页功能，内置通用列表 API"
          },
          "userSubscriptionManagement": {
            "title": "用户/订阅管理",
            "description": "即用型的用户和订阅管理页面"
          },
          "modernUIDesign": {
            "title": "现代化界面设计",
            "description": "使用 Nuxt UI 和 TailwindCSS 构建的精美组件"
          },
          "i18nReady": {
            "title": "多语言支持",
            "description": "内置多语言支持功能"
          },
          "responsiveLayout": {
            "title": "响应式布局",
            "description": "针对所有设备和屏幕尺寸优化"
          },
          "developerFriendly": {
            "title": "开发者友好",
            "description": "使用 ESLint + TypeScript 提供更好的开发体验"
          },
          "quickSetup": {
            "title": "快速搭建",
            "description": "几分钟内即可开始开发"
          },
          "customizable": {
            "title": "易于定制",
            "description": "轻松扩展和自定义组件"
          }
        }
      },
      "screenshots": {
        "title": "截图",
        "dashboard": "仪表盘",
        "users": "用户管理",
        "pricing": "价格方案",
        "subscription": "订阅管理",
        "signin": "登录"
      }
    }
  },
  "ja": {
    "home": {
      "slogan": "Nuxt.js フルスタック SaaS スターターキット - 無料＆オープンソース",
      "getStarted": "始めましょう",
      "viewOnGithub": "GitHub で見る",
      "features": {
        "title": "SaaS の成功のための堅固な基盤",
        "categories": {
          "foundation": "基盤",
          "integration": "統合機能",
          "admin": "管理機能",
          "experience": "ユーザー体験",
          "developer": "開発者向け"
        },
        "items": {
          "modernTechStack": {
            "title": "モダン技術スタック",
            "description": "Nuxt で構築され、Nuxt v4、TypeScript、Vue 3 Composition API に対応"
          },
          "secureAuth": {
            "title": "セキュア認証",
            "description": "Better Auth による堅牢な認証システム。OAuth2 ソーシャルログイン（Google、GitHub など）、サインイン/アップ、メールベースのパスワードリセット機能を提供。"
          },
          "enterpriseDatabase": {
            "title": "エンタープライズデータベース",
            "description": "PostgreSQL と Drizzle ORM による型安全な操作"
          },
          "emailIntegration": {
            "title": "メール統合",
            "description": "トランザクションメール用の Resend 統合機能搭載"
          },
          "paymentReady": {
            "title": "決済対応",
            "description": "サブスクリプション管理用の Stripe/Polar 統合"
          },
          "noVendorLockIn": {
            "title": "ベンダーロックインなし",
            "description": "交換可能なコンポーネントによるモジュラーアーキテクチャ"
          },
          "dashboard": {
            "title": "ダッシュボード",
            "description": "美しいチャートを備えた強力な管理ダッシュボード"
          },
          "advancedTables": {
            "title": "高度なテーブル",
            "description": "Notion/Airtable のような高度なフィルタリング、ソート、ページネーション機能とすぐに使える汎用リスト API"
          },
          "userSubscriptionManagement": {
            "title": "ユーザー/サブスクリプション管理",
            "description": "すぐに使えるユーザーとサブスクリプション管理ページ"
          },
          "modernUIDesign": {
            "title": "モダンな UI デザイン",
            "description": "Nuxt UI と TailwindCSS による美しいコンポーネント"
          },
          "i18nReady": {
            "title": "多言語対応",
            "description": "複数言語のサポートを標準搭載"
          },
          "responsiveLayout": {
            "title": "レスポンシブレイアウト",
            "description": "すべてのデバイスと画面サイズに最適化"
          },
          "developerFriendly": {
            "title": "開発者フレンドリー",
            "description": "ESLint + TypeScript でより良い開発体験"
          },
          "quickSetup": {
            "title": "クイックセットアップ",
            "description": "数分で開発を開始可能"
          },
          "customizable": {
            "title": "カスタマイズ可能",
            "description": "コンポーネントの拡張とカスタマイズが容易"
          }
        }
      },
      "screenshots": {
        "title": "スクリーンショット",
        "dashboard": "ダッシュボード",
        "users": "ユーザー管理",
        "pricing": "価格プラン",
        "subscription": "サブスクリプション管理",
        "signin": "ログイン"
      }
    }
  },
  "fr": {
    "home": {
      "slogan": "Kit de Démarrage SaaS Full-Stack Nuxt.js - Gratuit et Open Source",
      "getStarted": "Commencer",
      "viewOnGithub": "Voir sur GitHub",
      "features": {
        "title": "Base solide pour votre succès SaaS",
        "categories": {
          "foundation": "Fondation",
          "integration": "Intégration",
          "admin": "Administration",
          "experience": "Expérience",
          "developer": "Développeur"
        },
        "items": {
          "modernTechStack": {
            "title": "Stack Technologique Moderne",
            "description": "Construit avec Nuxt, prêt pour Nuxt v4, TypeScript et Vue 3 Composition API"
          },
          "secureAuth": {
            "title": "Authentification Sécurisée",
            "description": "Un système d'authentification robuste propulsé par Better Auth, offrant des connexions sociales OAuth2 (Google, GitHub, etc.), connexion/inscription, et réinitialisation de mot de passe par email."
          },
          "enterpriseDatabase": {
            "title": "Base de Données Enterprise",
            "description": "PostgreSQL avec Drizzle ORM pour des opérations sûres"
          },
          "emailIntegration": {
            "title": "Intégration Email",
            "description": "Intégration Resend intégrée pour les emails transactionnels"
          },
          "paymentReady": {
            "title": "Prêt pour le Paiement",
            "description": "Intégration Stripe/Polar pour la gestion des abonnements"
          },
          "noVendorLockIn": {
            "title": "Pas de Dépendance Fournisseur",
            "description": "Architecture modulaire avec composants interchangeables"
          },
          "dashboard": {
            "title": "Tableau de Bord",
            "description": "Un tableau de bord d'administration puissant avec de beaux graphiques"
          },
          "advancedTables": {
            "title": "Tables Avancées",
            "description": "Filtrage avancé, tri et pagination comme Notion/Airtable, avec API de liste générique intégrée"
          },
          "userSubscriptionManagement": {
            "title": "Gestion Utilisateurs/Abonnements",
            "description": "Page de gestion des utilisateurs et des abonnements prête à l'emploi"
          },
          "modernUIDesign": {
            "title": "Design UI Moderne",
            "description": "Beaux composants avec Nuxt UI et TailwindCSS"
          },
          "i18nReady": {
            "title": "Prêt pour l'I18n",
            "description": "Support intégré pour plusieurs langues"
          },
          "responsiveLayout": {
            "title": "Mise en Page Responsive",
            "description": "Optimisé pour tous les appareils et tailles d'écran"
          },
          "developerFriendly": {
            "title": "Adapté aux Développeurs",
            "description": "ESLint + TypeScript pour un meilleur développement"
          },
          "quickSetup": {
            "title": "Configuration Rapide",
            "description": "Commencez à développer en quelques minutes"
          },
          "customizable": {
            "title": "Personnalisable",
            "description": "Étendez et personnalisez facilement les composants"
          }
        }
      },
      "screenshots": {
        "title": "Captures d'écran",
        "dashboard": "Tableau de bord",
        "users": "Gestion des utilisateurs",
        "pricing": "Plans tarifaires",
        "subscription": "Gestion des abonnements",
        "signin": "Connexion"
      }
    }
  }
}



================================================
FILE: app/pages/index.vue
================================================
<i18n src="./index.json"></i18n>

<script setup lang="ts">
definePageMeta({
  auth: false,
  layout: false
})

const { t } = useI18n()
const localePath = useLocalePath()
const runtimeConfig = useRuntimeConfig()

const title = `${t('global.appName')}: ${t('home.slogan')}`
const desc = t('home.slogan')

useSeoMeta({
  title,
  description: desc,
  // Facebook
  ogTitle: title,
  ogDescription: desc,
  ogImage: '/screenshots/home.webp',
  // twitter
  twitterTitle: title,
  twitterDescription: desc,
  twitterImage: '/screenshots/home.webp'
})

const features = {
  foundation: [
    {
      icon: 'i-lucide-layout-template',
      title: t('home.features.items.modernTechStack.title'),
      description: t('home.features.items.modernTechStack.description')
    },
    {
      icon: 'i-lucide-shield-check',
      title: t('home.features.items.secureAuth.title'),
      description: t('home.features.items.secureAuth.description')
    },
    {
      icon: 'i-lucide-database',
      title: t('home.features.items.enterpriseDatabase.title'),
      description: t('home.features.items.enterpriseDatabase.description')
    }
  ],
  integration: [
    {
      icon: 'i-lucide-mail',
      title: t('home.features.items.emailIntegration.title'),
      description: t('home.features.items.emailIntegration.description')
    },
    {
      icon: 'i-lucide-credit-card',
      title: t('home.features.items.paymentReady.title'),
      description: t('home.features.items.paymentReady.description')
    },
    {
      icon: 'i-lucide-box',
      title: t('home.features.items.noVendorLockIn.title'),
      description: t('home.features.items.noVendorLockIn.description')
    }
  ],
  admin: [
    {
      icon: 'i-lucide-grid',
      title: t('home.features.items.dashboard.title'),
      description: t('home.features.items.dashboard.description')
    },
    {
      icon: 'i-lucide-users',
      title: t('home.features.items.advancedTables.title'),
      description: t('home.features.items.advancedTables.description')
    },
    {
      icon: 'i-lucide-file-text',
      title: t('home.features.items.userSubscriptionManagement.title'),
      description: t('home.features.items.userSubscriptionManagement.description')
    }
  ],
  experience: [
    {
      icon: 'i-lucide-palette',
      title: t('home.features.items.modernUIDesign.title'),
      description: t('home.features.items.modernUIDesign.description')
    },
    {
      icon: 'i-lucide-languages',
      title: t('home.features.items.i18nReady.title'),
      description: t('home.features.items.i18nReady.description')
    },
    {
      icon: 'i-lucide-smartphone',
      title: t('home.features.items.responsiveLayout.title'),
      description: t('home.features.items.responsiveLayout.description')
    }
  ],
  developer: [
    {
      icon: 'i-lucide-code',
      title: t('home.features.items.developerFriendly.title'),
      description: t('home.features.items.developerFriendly.description')
    },
    {
      icon: 'i-lucide-timer',
      title: t('home.features.items.quickSetup.title'),
      description: t('home.features.items.quickSetup.description')
    },
    {
      icon: 'i-lucide-settings',
      title: t('home.features.items.customizable.title'),
      description: t('home.features.items.customizable.description')
    }
  ]
}

const screenshots = [
  {
    label: t('home.screenshots.dashboard'),
    key: 'dashboard',
    src: '/screenshots/dashboard.webp'
  },
  {
    label: t('home.screenshots.users'),
    key: 'users',
    src: '/screenshots/users.webp'
  },
  {
    label: t('home.screenshots.subscription'),
    key: 'subscription',
    src: '/screenshots/subscription.webp'
  },
  {
    label: t('home.screenshots.pricing'),
    key: 'pricing',
    src: '/screenshots/pricing.webp'
  },
  {
    label: t('home.screenshots.signin'),
    key: 'signin',
    src: '/screenshots/signin.webp'
  }
]
const activeScreenshot = ref('0')
</script>

<template>
  <NuxtLayout name="default">
    <template #nav-center>
      <SiteNavigation
        mode="desktop"
        class="hidden sm:flex"
      />
    </template>
    <template #nav-right>
      <div class="flex items-center gap-2">
        <UserNavigation />
        <SiteNavigation
          mode="mobile"
          class="flex sm:hidden"
        />
      </div>
    </template>
    <div class="pt-16">
      <div class="absolute inset-0 bg-gradient-to-b from-emerald-50 to-white dark:from-gray-900 dark:to-gray-800" />
      <div class="absolute inset-0">
        <div class="absolute inset-0 bg-gradient-to-r from-emerald-500/10 to-teal-500/10 blur-3xl opacity-50" />
        <div class="absolute top-0 left-0 w-[500px] h-[500px] bg-teal-500/20 rounded-full blur-3xl -ml-32 -mt-32 opacity-30" />
      </div>
      <!-- Hero Section -->
      <section class="relative overflow-hidden">
        <UContainer class="relative py-24">
          <div class="text-center">
            <h1 class="text-4xl font-bold tracking-tight sm:text-7xl mb-6">
              {{ t('global.appName') }}
            </h1>
            <p class="text-lg text-gray-600 dark:text-gray-400 mb-8">
              {{ t('home.slogan') }}
            </p>
            <div class="flex gap-4 justify-center">
              <UButton
                :to="localePath('/signin')"
                color="primary"
                size="lg"
              >
                {{ t('home.getStarted') }}
              </UButton>
              <UButton
                :to="runtimeConfig.public.appRepo"
                target="_blank"
                color="neutral"
                variant="outline"
                size="lg"
                icon="i-simple-icons-github"
              >
                {{ t('home.viewOnGithub') }}
              </UButton>
            </div>
          </div>
        </UContainer>
      </section>

      <!-- Screenshots Section -->
      <section class="relative mt-20">
        <UContainer>
          <div class="text-center mb-4">
            <h2 class="text-3xl font-bold">
              {{ t('home.screenshots.title') }}
            </h2>
          </div>
          <UTabs
            :items="screenshots"
            class="w-full hidden sm:block"
          >
            <template #content="{ item }">
              <div class="rounded-lg overflow-hidden border border-gray-200 dark:border-gray-700 shadow-lg">
                <img
                  :src="item.src"
                  :alt="item.label"
                  class="w-full h-auto"
                  loading="lazy"
                >
              </div>
            </template>
          </UTabs>
          <UAccordion
            v-model="activeScreenshot"
            :items="screenshots"
            class="w-full block sm:hidden"
          >
            <template #content="{ item }">
              <div class="rounded-lg overflow-hidden border border-gray-200 dark:border-gray-700 shadow-lg">
                <img
                  :src="item.src"
                  :alt="item.label"
                  class="w-full h-auto"
                  loading="lazy"
                >
              </div>
            </template>
          </UAccordion>
        </UContainer>
      </section>

      <!-- Features Section -->
      <section
        id="features"
        class="relative py-24 bg-gray-50/50 dark:bg-gray-900/50"
      >
        <UContainer>
          <div class="text-center mb-12">
            <h2 class="text-3xl font-bold">
              {{ t('home.features.title') }}
            </h2>
          </div>
          <!-- Feature Groups -->
          <div class="space-y-24">
            <div
              v-for="(group, key) in features"
              :key="key"
              class="space-y-8"
            >
              <h3 class="text-xl font-semibold capitalize text-center">
                {{ t(`home.features.categories.${key}`) }}
              </h3>
              <div class="grid md:grid-cols-2 lg:grid-cols-3 gap-8">
                <UCard
                  v-for="feature in group"
                  :key="feature.title"
                  class="bg-white/80 dark:bg-gray-800/80 backdrop-blur border-0 shadow hover:shadow-lg transition-shadow duration-200"
                >
                  <div class="flex gap-4 items-start p-2">
                    <div class="shrink-0">
                      <div class="p-3 bg-primary-50 dark:bg-primary-900/50 rounded-lg">
                        <UIcon
                          :name="feature.icon"
                          class="text-primary-500 w-5 h-5"
                        />
                      </div>
                    </div>
                    <div>
                      <h4 class="font-medium mb-2">
                        {{ feature.title }}
                      </h4>
                      <p class="text-sm text-gray-600 dark:text-gray-400">
                        {{ feature.description }}
                      </p>
                    </div>
                  </div>
                </UCard>
              </div>
            </div>
          </div>
        </UContainer>
      </section>
    </div>
  </NuxtLayout>
</template>



================================================
FILE: app/pages/403/i18n.json
================================================
{
  "en": {
    "403": {
      "title": "Access Denied",
      "message": "Sorry, you don't have permission to access this page.",
      "back": "Back to home"
    }
  },
  "zh-CN": {
    "403": {
      "title": "访问被拒绝",
      "message": "抱歉，您没有权限访问此页面。",
      "back": "返回首页"
    }
  },
  "ja": {
    "403": {
      "title": "アクセス拒否",
      "message": "申し訳ありませんが、このページにアクセスする権限がありません。",
      "back": "ホームに戻る"
    }
  },
  "fr": {
    "403": {
      "title": "Accès Refusé",
      "message": "Désolé, vous n'avez pas la permission d'accéder à cette page.",
      "back": "Retour à l'accueil"
    }
  }
}



================================================
FILE: app/pages/403/index.vue
================================================
<i18n src="./i18n.json"></i18n>

<script setup lang="ts">
const localePath = useLocalePath()
const { t } = useI18n()
</script>

<template>
  <div class="flex flex-1 flex-col items-center justify-center">
    <div class="text-center">
      <UIcon
        name="lucide:shield-alert"
        class="mx-auto h-16 w-16 text-red-500 dark:text-red-400"
      />
      <h1 class="mt-4 text-3xl font-bold tracking-tight text-gray-900 dark:text-white">
        {{ t('403.title') }}
      </h1>
      <p class="mt-2 text-base text-gray-500 dark:text-gray-400">
        {{ t('403.message') }}
      </p>
      <div class="mt-6">
        <UButton
          :to="localePath('/')"
          icon="lucide:home"
          variant="soft"
        >
          {{ t('403.back') }}
        </UButton>
      </div>
    </div>
  </div>
</template>



================================================
FILE: app/pages/admin/dashboard/i18n.json
================================================
{
  "en": {
    "dashboard": {
      "stats": {
        "activeUsers": "Active Users",
        "totalRevenue": "Total Revenue",
        "activeProjects": "Active Projects",
        "customerSatisfaction": "Customer Satisfaction"
      },
      "revenueChart": {
        "title": "Revenue Growth"
      },
      "userDistribution": {
        "title": "User Distribution by Plan"
      }
    }
  },
  "zh-CN": {
    "dashboard": {
      "stats": {
        "activeUsers": "活跃用户",
        "totalRevenue": "总收入",
        "activeProjects": "活跃项目",
        "customerSatisfaction": "客户满意度"
      },
      "revenueChart": {
        "title": "收入增长"
      },
      "userDistribution": {
        "title": "用户方案分布"
      }
    }
  },
  "ja": {
    "dashboard": {
      "stats": {
        "activeUsers": "アクティブユーザー",
        "totalRevenue": "総収入",
        "activeProjects": "アクティブプロジェクト",
        "customerSatisfaction": "顧客満足度"
      },
      "revenueChart": {
        "title": "収益成長"
      },
      "userDistribution": {
        "title": "プラン別ユーザー分布"
      }
    }
  },
  "fr": {
    "dashboard": {
      "stats": {
        "activeUsers": "Utilisateurs Actifs",
        "totalRevenue": "Revenu Total",
        "activeProjects": "Projets Actifs",
        "customerSatisfaction": "Satisfaction Client"
      },
      "revenueChart": {
        "title": "Croissance des Revenus"
      },
      "userDistribution": {
        "title": "Distribution des Utilisateurs par Plan"
      }
    }
  }
}



================================================
FILE: app/pages/admin/dashboard/index.vue
================================================
<i18n src="./i18n.json"></i18n>

<script setup lang="ts">
const { t } = useI18n()

const stats = ref([
  {
    name: 'activeUsers',
    value: '2,834',
    change: '+12.5%',
    isIncrease: true,
    icon: 'users'
  },
  {
    name: 'totalRevenue',
    value: '$45,289',
    change: '+8.2%',
    isIncrease: true,
    icon: 'dollar-sign'
  },
  {
    name: 'activeProjects',
    value: '156',
    change: '-3.1%',
    isIncrease: false,
    icon: 'folder'
  },
  {
    name: 'customerSatisfaction',
    value: '94.8%',
    change: '+2.3%',
    isIncrease: true,
    icon: 'smile'
  }
])

const RevenueData = [
  { month: 'January', desktop: 186, mobile: 80 },
  { month: 'February', desktop: 305, mobile: 200 },
  { month: 'March', desktop: 237, mobile: 120 },
  { month: 'April', desktop: 73, mobile: 190 },
  { month: 'May', desktop: 209, mobile: 130 },
  { month: 'June', desktop: 214, mobile: 140 }
]
const RevenueCategoriesMultple = {
  desktop: { name: 'Desktop', color: '#029752' },
  mobile: { name: 'Mobile', color: '#4ade80' }
}

const categories: Record<string, BulletLegendItemInterface> = {
  desktop: { name: 'Desktop', color: '#029752' },
  mobile: { name: 'Mobile', color: '#4ade80' }
}

const AreaChartData = [
  { date: '2024-04-01', desktop: 222, mobile: 150 },
  { date: '2024-04-02', desktop: 180, mobile: 97 },
  { date: '2024-04-03', desktop: 167, mobile: 120 },
  { date: '2024-04-04', desktop: 260, mobile: 240 },
  { date: '2024-04-05', desktop: 240, mobile: 290 }
]

const xFormatter = (i: number): string | number => AreaChartData[i]?.date || ''
</script>

<template>
  <NuxtLayout name="admin">
    <div class="space-y-8">
      <div class="grid grid-cols-1 gap-4 sm:grid-cols-2 lg:grid-cols-4">
        <UCard
          v-for="stat in stats"
          :key="stat.name"
          class="relative overflow-hidden"
        >
          <div class="flex items-center justify-between">
            <div>
              <div class="text-sm text-gray-500 dark:text-gray-400">
                {{ t(`dashboard.stats.${stat.name}`) }}
              </div>
              <div class="mt-1 text-2xl font-semibold">
                {{ stat.value }}
              </div>
              <div
                class="mt-2 flex items-center text-sm"
                :class="stat.isIncrease ? 'text-green-600 dark:text-green-400' : 'text-red-600 dark:text-red-400'"
              >
                <Icon
                  :name="stat.isIncrease ? 'lucide:trending-up' : 'lucide:trending-down'"
                  class="mr-1 h-4 w-4"
                />
                {{ stat.change }}
              </div>
            </div>
            <Icon
              :name="`lucide:${stat.icon}`"
              class="h-8 w-8 text-gray-400 dark:text-gray-600"
            />
          </div>
        </UCard>
      </div>

      <!-- Charts -->
      <div class="grid grid-cols-1 gap-4 lg:grid-cols-2">
        <UCard>
          <AreaChart
            :data="AreaChartData"
            :height="250"
            :categories="categories"
            :y-num-ticks="4"
            :x-num-ticks="7"
            :grid-line-y="true"
            legend-poisition="top"
            :x-formatter="xFormatter"
          />
        </UCard>
        <UCard>
          <BarChart
            :data="RevenueData"
            :stacked="true"
            :height="250"
            :categories="RevenueCategoriesMultple"
            :y-axis="['desktop', 'mobile']"
            :group-padding="0"
            :bar-padding="0.2"
            :x-num-ticks="6"
            :radius="4"
            :orientation="Orientation.Horizontal"
            :x-formatter="(i) => i"
            :y-formatter="(i: number): string => `${RevenueData[i]!.month}`"
            :legend-position="LegendPosition.Top"
          />
        </UCard>
      </div>
    </div>
  </NuxtLayout>
</template>



================================================
FILE: app/pages/admin/maintenance/audit-log/i18n.json
================================================
{
  "en": {
    "auditLog": {
      "title": "Audit Log",
      "category": "Category",
      "categories": {
        "auth": "Authentication",
        "email": "Email",
        "payment": "Payment"
      },
      "action": "Action",
      "targetType": "Target Type",
      "targetId": "Target ID",
      "ipAddress": "IP Address",
      "userAgent": "User Agent",
      "status": {
        "success": "Success",
        "failure": "Failure",
        "pending": "Pending"
      },
      "details": "Details",
      "createdAt": "Created At"
    }
  },
  "zh-CN": {
    "auditLog": {
      "title": "审计日志",
      "category": "分类",
      "categories": {
        "auth": "认证",
        "email": "邮件",
        "payment": "支付"
      },
      "action": "操作",
      "targetType": "目标类型",
      "targetId": "目标ID",
      "ipAddress": "IP地址",
      "userAgent": "用户代理",
      "status": {
        "success": "成功",
        "failure": "失败",
        "pending": "处理中"
      },
      "details": "详情",
      "createdAt": "创建时间"
    }
  },
  "ja": {
    "auditLog": {
      "title": "監査ログ",
      "category": "カテゴリー",
      "categories": {
        "auth": "認証",
        "email": "メール",
        "payment": "支払い"
      },
      "action": "アクション",
      "targetType": "対象タイプ",
      "targetId": "対象ID",
      "ipAddress": "IPアドレス",
      "userAgent": "ユーザーエージェント",
      "status": {
        "success": "成功",
        "failure": "失敗",
        "pending": "保留中"
      },
      "details": "詳細",
      "createdAt": "作成日時"
    }
  },
  "fr": {
    "auditLog": {
      "title": "Journal d'audit",
      "category": "Catégorie",
      "categories": {
        "auth": "Authentification",
        "email": "E-mail",
        "payment": "Paiement"
      },
      "action": "Action",
      "targetType": "Type de cible",
      "targetId": "ID de cible",
      "ipAddress": "Adresse IP",
      "userAgent": "Agent utilisateur",
      "status": {
        "success": "Succès",
        "failure": "Échec",
        "pending": "En attente"
      },
      "details": "Détails",
      "createdAt": "Créé le"
    }
  }
}



================================================
FILE: app/pages/admin/maintenance/audit-log/index.vue
================================================
<i18n src="./i18n.json"></i18n>

<script setup lang="ts">
interface AuditLog {
  id: number
  userId: string | null
  category: string
  action: string
  targetType: string | null
  targetId: string | null
  ipAddress: string | null
  userAgent: string | null
  status: 'success' | 'failure' | 'pending'
  details: string | null
  createdAt: string // ISO timestamp string
}

const { t } = useI18n()

const filters: AdminTableFilter[] = reactive([
  {
    name: t('auditLog.category'),
    field: 'category',
    type: 'tabs',
    items: [
      { label: t('global.page.all'), id: '' },
      { label: t('auditLog.categories.auth'), id: 'auth' },
      { label: t('auditLog.categories.email'), id: 'email' },
      { label: t('auditLog.categories.payment'), id: 'payment' }
    ],
    value: ''
  },
  {
    name: t('global.page.status'),
    field: 'status',
    type: 'checkbox' as const,
    items: [
      { label: t('auditLog.status.success'), id: 'success', count: 0 },
      { label: t('auditLog.status.failure'), id: 'failure', count: 0 },
      { label: t('auditLog.status.pending'), id: 'pending', count: 0 }
    ],
    value: []
  },
  {
    name: t('global.page.createdAt'),
    field: 'createdAt',
    type: 'daterange',
    value: { start: undefined, end: undefined }
  }
])

const columns: AdminTableColumn<AuditLog>[] = [
  {
    accessorKey: 'id',
    header: 'ID'
  },
  {
    accessorKey: 'category',
    header: t('auditLog.category')
  },
  {
    accessorKey: 'action',
    header: t('auditLog.action')
  },
  {
    accessorKey: 'targetType',
    header: t('auditLog.targetType')
  },
  {
    accessorKey: 'targetId',
    header: t('auditLog.targetId')
  },
  {
    accessorKey: 'status',
    header: t('global.page.status')
  },
  {
    accessorKey: 'ipAddress',
    header: t('auditLog.ipAddress')
  },
  {
    accessorKey: 'userAgent',
    header: t('auditLog.userAgent'),
    cell: cell => showMoreColumn(cell, 20)
  },
  {
    accessorKey: 'details',
    header: t('auditLog.details'),
    cell: cell => showMoreColumn(cell, 20)
  },
  {
    accessorKey: 'createdAt',
    header: t('global.page.createdAt'),
    cell: dateColumn
  }
]

const getStatusColor = (status: string): 'success' | 'warning' | 'error' => {
  switch (status) {
    case 'success':
      return 'success'
    case 'pending':
      return 'warning'
    case 'failure':
      return 'error'
    default:
      return 'warning'
  }
}

const fetchStatusCount = async (filter: FilterCondition[]) => {
  const statusCount = await $fetch<ColumnCount[]>('/api/admin/count/auditLog/status', {
    query: {
      filter: JSON.stringify(filter)
    }
  })
  const statusFilter = filters[1] as FilterTabs
  statusFilter.items.forEach((item) => {
    const status = statusCount.find(status => status.column === item.id)
    item.count = status ? status.count : 0
  })
}

const fetchData: FetchDataFn<AuditLog> = async ({ page, limit, sort, filter }) => {
  fetchStatusCount(filter)
  const result = await $fetch<PageData<AuditLog>>('/api/admin/list/auditLog', {
    query: {
      page,
      limit,
      sort: JSON.stringify(sort.map((item) => {
        return [item.field, item.order]
      })),
      filter: JSON.stringify(filter)
    }
  })
  return {
    data: result.data,
    total: result.total
  }
}
</script>

<template>
  <NuxtLayout name="admin">
    <AdminTable
      :columns="columns"
      :filters="filters"
      :fetch-data="fetchData"
    >
      <template #status-cell="{ row: { original } }">
        <UBadge
          :color="getStatusColor(original.status)"
          :label="t(`auditLog.status.${original.status}`)"
        />
      </template>
    </AdminTable>
  </NuxtLayout>
</template>



================================================
FILE: app/pages/admin/maintenance/db-stats/i18n.json
================================================
{
  "en": {
    "dbStats": {
      "performance": "Performance Statistics",
      "activeBackends": "Active Backends",
      "transactions": "Transactions",
      "commits": "Commits",
      "rollbacks": "Rollbacks",
      "tuples": "Tuples",
      "inserted": "Inserted",
      "updated": "Updated",
      "deleted": "Deleted",
      "cacheHitRatio": "Cache Hit Ratio",
      "conflicts": "Conflicts",
      "deadlocks": "Deadlocks",
      "tempFiles": "Temporary Files",
      "tempBytes": "Temporary Bytes"
    }
  },
  "zh-CN": {
    "dbStats": {
      "performance": "性能统计",
      "activeBackends": "活动后端",
      "transactions": "事务",
      "commits": "提交数",
      "rollbacks": "回滚数",
      "tuples": "元组",
      "inserted": "插入",
      "updated": "更新",
      "deleted": "删除",
      "cacheHitRatio": "缓存命中率",
      "conflicts": "冲突数",
      "deadlocks": "死锁数",
      "tempFiles": "临时文件",
      "tempBytes": "临时文件大小"
    }
  },
  "ja": {
    "dbStats": {
      "performance": "パフォーマンス統計",
      "activeBackends": "アクティブバックエンド",
      "transactions": "トランザクション",
      "commits": "コミット数",
      "rollbacks": "ロールバック数",
      "tuples": "タプル",
      "inserted": "挿入",
      "updated": "更新",
      "deleted": "削除",
      "cacheHitRatio": "キャッシュヒット率",
      "conflicts": "競合数",
      "deadlocks": "デッドロック数",
      "tempFiles": "一時ファイル",
      "tempBytes": "一時ファイルサイズ"
    }
  },
  "fr": {
    "dbStats": {
      "performance": "Statistiques de Performance",
      "activeBackends": "Backends Actifs",
      "transactions": "Transactions",
      "commits": "Validations",
      "rollbacks": "Annulations",
      "tuples": "Tuples",
      "inserted": "Insérés",
      "updated": "Mis à jour",
      "deleted": "Supprimés",
      "cacheHitRatio": "Taux de Cache",
      "conflicts": "Conflits",
      "deadlocks": "Verrous Mortels",
      "tempFiles": "Fichiers Temporaires",
      "tempBytes": "Taille Temporaire"
    }
  }
}



================================================
FILE: app/pages/admin/maintenance/db-stats/index.vue
================================================
<i18n src="./i18n.json"></i18n>

<script setup lang="ts">
const { t } = useI18n()
const { data: dbStats } = await useFetch('/api/admin/maintenance/db-stats')

// Format bytes to human readable format
function formatBytes(bytes: number) {
  if (bytes === 0)
    return '0 B'
  const k = 1024
  const sizes = ['B', 'KB', 'MB', 'GB']
  const i = Math.floor(Math.log(bytes) / Math.log(k))
  return `${Number.parseFloat((bytes / k ** i).toFixed(2))} ${sizes[i]}`
}
</script>

<template>
  <NuxtLayout name="admin">
    <UCard class="mt-4">
      <template #header>
        <div class="flex items-center gap-2">
          <Icon name="lucide:bar-chart" />
          <span>{{ t('dbStats.performance') }}</span>
        </div>
      </template>

      <div class="grid gap-4 sm:grid-cols-2 lg:grid-cols-3">
        <UCard>
          <div class="space-y-4">
            <div>
              <div class="text-sm text-gray-500 dark:text-gray-400">
                {{ t('dbStats.activeBackends') }}
              </div>
              <div class="text-xl">
                {{ dbStats?.activeBackends }}
              </div>
            </div>

            <USeparator />

            <div>
              <div class="text-sm text-gray-500 dark:text-gray-400">
                {{ t('dbStats.transactions') }}
              </div>
              <div class="mt-1 grid grid-cols-2 gap-2">
                <div>
                  <div class="text-sm text-success-500">
                    {{ t('dbStats.commits') }}
                  </div>
                  <div>{{ dbStats?.transactions.commits }}</div>
                </div>
                <div>
                  <div class="text-sm text-error-500">
                    {{ t('dbStats.rollbacks') }}
                  </div>
                  <div>{{ dbStats?.transactions.rollbacks }}</div>
                </div>
              </div>
            </div>
          </div>
        </UCard>

        <UCard>
          <div class="space-y-4">
            <div>
              <div class="text-sm text-gray-500 dark:text-gray-400">
                {{ t('dbStats.tuples') }}
              </div>
              <div class="mt-1 grid grid-cols-3 gap-2">
                <div>
                  <div class="text-sm text-success-500">
                    {{ t('dbStats.inserted') }}
                  </div>
                  <div>{{ dbStats?.tuples.inserted }}</div>
                </div>
                <div>
                  <div class="text-sm text-warning-500">
                    {{ t('dbStats.updated') }}
                  </div>
                  <div>{{ dbStats?.tuples.updated }}</div>
                </div>
                <div>
                  <div class="text-sm text-error-500">
                    {{ t('dbStats.deleted') }}
                  </div>
                  <div>{{ dbStats?.tuples.deleted }}</div>
                </div>
              </div>
            </div>

            <USeparator />

            <div>
              <div class="text-sm text-gray-500 dark:text-gray-400">
                {{ t('dbStats.cacheHitRatio') }}
              </div>
              <div class="text-xl">
                {{ dbStats?.cacheHitRatio }}%
              </div>
            </div>
          </div>
        </UCard>

        <UCard>
          <div class="space-y-4">
            <div>
              <div class="text-sm text-gray-500 dark:text-gray-400">
                {{ t('dbStats.tempFiles') }}
              </div>
              <div class="mt-1">
                <div class="text-xl">
                  {{ dbStats?.tempFiles.count }}
                </div>
                <div
                  v-if="dbStats?.tempFiles.bytes"
                  class="text-sm text-gray-500 dark:text-gray-400"
                >
                  {{ formatBytes(dbStats.tempFiles.bytes) }}
                </div>
              </div>
            </div>

            <USeparator />

            <div class="grid grid-cols-2 gap-4">
              <div>
                <div class="text-sm text-gray-500 dark:text-gray-400">
                  {{ t('dbStats.conflicts') }}
                </div>
                <div class="text-xl text-warning-500">
                  {{ dbStats?.conflicts }}
                </div>
              </div>
              <div>
                <div class="text-sm text-gray-500 dark:text-gray-400">
                  {{ t('dbStats.deadlocks') }}
                </div>
                <div class="text-xl text-error-500">
                  {{ dbStats?.deadlocks }}
                </div>
              </div>
            </div>
          </div>
        </UCard>
      </div>

      <div
        v-if="!dbStats"
        class="text-center"
      >
        <UIcon
          name="i-lucide-loader-2"
          class="animate-spin"
        />
      </div>
    </UCard>
  </NuxtLayout>
</template>



================================================
FILE: app/pages/admin/maintenance/migration/i18n.json
================================================
{
  "en": {
    "migration": {
      "title": "Data Migration",
      "description": "Manage various data migration operations for system maintenance and data integrity.",
      "operations": "Available Operations",
      "paymentCustomers": {
        "title": "Payment Customers Management",
        "description": "Ensure all users have corresponding payment provider customer records. This operation will create missing Stripe and Polar customer records for existing users.",
        "execute": "Execute Ensure Payment Customers",
        "summary": "Execution Summary",
        "totalUsers": "Total Users",
        "stripeSuccess": "Stripe Success",
        "stripeError": "Stripe Errors",
        "polarSuccess": "Polar Success",
        "polarError": "Polar Errors",
        "stripeResults": "Stripe Results",
        "polarResults": "Polar Results",
        "status": {
          "success": "Success",
          "error": "Error"
        }
      },
      "common": {
        "execute": "Execute",
        "executing": "Executing...",
        "completed": "Completed",
        "failed": "Failed",
        "noResults": "No results to display",
        "backToOperations": "Back to Operations"
      }
    }
  },
  "zh-CN": {
    "migration": {
      "title": "数据迁移",
      "description": "管理各种数据迁移操作，用于系统维护和数据完整性。",
      "operations": "可用操作",
      "paymentCustomers": {
        "title": "支付客户管理",
        "description": "确保所有用户都有对应的支付提供商客户记录。此操作将为现有用户创建缺失的 Stripe 和 Polar 客户记录。",
        "execute": "执行确保支付客户",
        "summary": "执行摘要",
        "totalUsers": "总用户数",
        "stripeSuccess": "Stripe 成功",
        "stripeError": "Stripe 错误",
        "polarSuccess": "Polar 成功",
        "polarError": "Polar 错误",
        "stripeResults": "Stripe 结果",
        "polarResults": "Polar 结果",
        "status": {
          "success": "成功",
          "error": "错误"
        }
      },
      "common": {
        "execute": "执行",
        "executing": "执行中...",
        "completed": "已完成",
        "failed": "失败",
        "noResults": "无结果显示",
        "backToOperations": "返回操作列表"
      }
    }
  },
  "ja": {
    "migration": {
      "title": "データ移行",
      "description": "システムメンテナンスとデータ整合性のための各種データ移行操作を管理します。",
      "operations": "利用可能な操作",
      "paymentCustomers": {
        "title": "支払い顧客管理",
        "description": "すべてのユーザーが対応する支払いプロバイダーの顧客記録を持つことを確認します。この操作により、既存のユーザーに不足しているStripeとPolarの顧客記録が作成されます。",
        "execute": "支払い顧客確保を実行",
        "summary": "実行概要",
        "totalUsers": "総ユーザー数",
        "stripeSuccess": "Stripe 成功",
        "stripeError": "Stripe エラー",
        "polarSuccess": "Polar 成功",
        "polarError": "Polar エラー",
        "stripeResults": "Stripe 結果",
        "polarResults": "Polar 結果",
        "status": {
          "success": "成功",
          "error": "エラー"
        }
      },
      "common": {
        "execute": "実行",
        "executing": "実行中...",
        "completed": "完了",
        "failed": "失敗",
        "noResults": "表示する結果がありません",
        "backToOperations": "操作一覧に戻る"
      }
    }
  },
  "fr": {
    "migration": {
      "title": "Migration de Données",
      "description": "Gérer diverses opérations de migration de données pour la maintenance du système et l'intégrité des données.",
      "operations": "Opérations Disponibles",
      "paymentCustomers": {
        "title": "Gestion des Clients de Paiement",
        "description": "Assurez-vous que tous les utilisateurs ont des enregistrements de clients correspondants chez les fournisseurs de paiement. Cette opération créera les enregistrements clients Stripe et Polar manquants pour les utilisateurs existants.",
        "execute": "Exécuter l'Assurance des Clients de Paiement",
        "summary": "Résumé d'Exécution",
        "totalUsers": "Total des Utilisateurs",
        "stripeSuccess": "Stripe Succès",
        "stripeError": "Erreurs Stripe",
        "polarSuccess": "Polar Succès",
        "polarError": "Erreurs Polar",
        "stripeResults": "Résultats Stripe",
        "polarResults": "Résultats Polar",
        "status": {
          "success": "Succès",
          "error": "Erreur"
        }
      },
      "common": {
        "execute": "Exécuter",
        "executing": "En cours d'exécution...",
        "completed": "Terminé",
        "failed": "Échoué",
        "noResults": "Aucun résultat à afficher",
        "backToOperations": "Retour aux Opérations"
      }
    }
  }
}



================================================
FILE: app/pages/admin/maintenance/migration/index.vue
================================================
<i18n src="./i18n.json"></i18n>

<script setup lang="ts">
interface MigrationOperation {
  id: string
  title: string
  description: string
  icon: string
  color: 'primary' | 'secondary' | 'success' | 'warning' | 'error'
  endpoint: string
}

const { t } = useI18n()
const currentOperation = ref<string | null>(null)
const isLoading = ref(false)
const result = ref<any>(null)
const error = ref<string | null>(null)

const operations: MigrationOperation[] = [
  {
    id: 'payment-customers',
    title: t('migration.paymentCustomers.title'),
    description: t('migration.paymentCustomers.description'),
    icon: 'lucide:credit-card',
    color: 'primary',
    endpoint: '/api/admin/maintenance/ensure-payment-customers'
  }
  // Future operations can be added here
  // {
  //   id: 'user-profiles',
  //   title: 'User Profile Migration',
  //   description: 'Migrate user profile data to new schema',
  //   icon: 'lucide:user',
  //   color: 'secondary',
  //   endpoint: '/api/admin/maintenance/migrate-user-profiles'
  // }
]

const selectOperation = (operationId: string) => {
  currentOperation.value = operationId
  result.value = null
  error.value = null
}

const backToOperations = () => {
  currentOperation.value = null
  result.value = null
  error.value = null
  isLoading.value = false
}

const executeOperation = async () => {
  const operation = operations.find(op => op.id === currentOperation.value)
  if (!operation)
    return

  isLoading.value = true
  error.value = null
  result.value = null

  try {
    const response = await $fetch(operation.endpoint)
    result.value = response
  } catch (err) {
    error.value = err instanceof Error ? err.message : 'Unknown error'
  } finally {
    isLoading.value = false
  }
}

const getStatusColor = (status: string): 'success' | 'error' => {
  return status === 'success' ? 'success' : 'error'
}

const getCurrentOperation = () => {
  return operations.find(op => op.id === currentOperation.value)
}
</script>

<template>
  <NuxtLayout name="admin">
    <div class="space-y-6">
      <!-- Main Header -->
      <UCard>
        <template #header>
          <div class="flex items-center gap-2">
            <Icon name="lucide:database" />
            <span>{{ t('migration.title') }}</span>
          </div>
        </template>

        <p class="text-gray-600 dark:text-gray-400">
          {{ t('migration.description') }}
        </p>
      </UCard>

      <!-- Operations List View -->
      <div v-if="!currentOperation">
        <UCard>
          <template #header>
            <div class="flex items-center gap-2">
              <Icon name="lucide:list" />
              <span>{{ t('migration.operations') }}</span>
            </div>
          </template>

          <div class="grid gap-4 sm:grid-cols-1 lg:grid-cols-2">
            <UCard
              v-for="operation in operations"
              :key="operation.id"
              class="cursor-pointer hover:shadow-md transition-shadow"
              @click="selectOperation(operation.id)"
            >
              <div class="flex items-start gap-4">
                <div class="flex-shrink-0">
                  <div :class="`p-3 rounded-lg bg-${operation.color}-100 dark:bg-${operation.color}-900/20`">
                    <Icon
                      :name="operation.icon"
                      :class="`w-6 h-6 text-${operation.color}-600 dark:text-${operation.color}-400`"
                    />
                  </div>
                </div>
                <div class="flex-1 min-w-0">
                  <h3 class="text-lg font-semibold text-gray-900 dark:text-gray-100">
                    {{ operation.title }}
                  </h3>
                  <p class="text-sm text-gray-600 dark:text-gray-400 mt-1">
                    {{ operation.description }}
                  </p>
                  <div class="mt-3">
                    <UButton
                      :color="operation.color"
                      size="sm"
                    >
                      {{ t('migration.common.execute') }}
                      <Icon name="lucide:arrow-right" />
                    </UButton>
                  </div>
                </div>
              </div>
            </UCard>
          </div>
        </UCard>
      </div>

      <!-- Operation Execution View -->
      <div v-else>
        <!-- Operation Header -->
        <UCard>
          <template #header>
            <div class="flex items-center justify-between">
              <div class="flex items-center gap-2">
                <Icon :name="getCurrentOperation()?.icon || 'lucide:settings'" />
                <span>{{ getCurrentOperation()?.title }}</span>
              </div>
              <UButton
                variant="ghost"
                size="sm"
                @click="backToOperations"
              >
                <Icon name="lucide:arrow-left" />
                {{ t('migration.common.backToOperations') }}
              </UButton>
            </div>
          </template>

          <div class="space-y-4">
            <p class="text-gray-600 dark:text-gray-400">
              {{ getCurrentOperation()?.description }}
            </p>

            <UButton
              :loading="isLoading"
              :disabled="isLoading"
              :color="getCurrentOperation()?.color || 'primary'"
              @click="executeOperation"
            >
              <Icon name="lucide:play" />
              {{ isLoading ? t('migration.common.executing') : t('migration.common.execute') }}
            </UButton>
          </div>
        </UCard>

        <!-- Error Display -->
        <UCard
          v-if="error"
          class="border-red-200 dark:border-red-800"
        >
          <template #header>
            <div class="flex items-center gap-2 text-red-600 dark:text-red-400">
              <Icon name="lucide:alert-circle" />
              <span>{{ t('global.page.error') }}</span>
            </div>
          </template>

          <p class="text-red-600 dark:text-red-400">
            {{ error }}
          </p>
        </UCard>

        <!-- Payment Customers Results -->
        <div
          v-if="result && currentOperation === 'payment-customers'"
          class="space-y-6"
        >
          <!-- Summary Card -->
          <UCard>
            <template #header>
              <div class="flex items-center gap-2">
                <Icon name="lucide:bar-chart" />
                <span>{{ t('migration.paymentCustomers.summary') }}</span>
              </div>
            </template>

            <div class="grid gap-4 sm:grid-cols-2 lg:grid-cols-5">
              <div class="text-center">
                <div class="text-2xl font-bold">
                  {{ result.summary.totalUsers }}
                </div>
                <div class="text-sm text-gray-500 dark:text-gray-400">
                  {{ t('migration.paymentCustomers.totalUsers') }}
                </div>
              </div>

              <div class="text-center">
                <div class="text-2xl font-bold text-green-600">
                  {{ result.summary.stripeSuccessCount }}
                </div>
                <div class="text-sm text-gray-500 dark:text-gray-400">
                  {{ t('migration.paymentCustomers.stripeSuccess') }}
                </div>
              </div>

              <div class="text-center">
                <div class="text-2xl font-bold text-red-600">
                  {{ result.summary.stripeErrorCount }}
                </div>
                <div class="text-sm text-gray-500 dark:text-gray-400">
                  {{ t('migration.paymentCustomers.stripeError') }}
                </div>
              </div>

              <div class="text-center">
                <div class="text-2xl font-bold text-green-600">
                  {{ result.summary.polarSuccessCount }}
                </div>
                <div class="text-sm text-gray-500 dark:text-gray-400">
                  {{ t('migration.paymentCustomers.polarSuccess') }}
                </div>
              </div>

              <div class="text-center">
                <div class="text-2xl font-bold text-red-600">
                  {{ result.summary.polarErrorCount }}
                </div>
                <div class="text-sm text-gray-500 dark:text-gray-400">
                  {{ t('migration.paymentCustomers.polarError') }}
                </div>
              </div>
            </div>
          </UCard>

          <!-- Detailed Results -->
          <div class="grid gap-6 lg:grid-cols-2">
            <!-- Stripe Results -->
            <UCard v-if="result.data.stripeResults.length > 0">
              <template #header>
                <div class="flex items-center gap-2">
                  <Icon name="simple-icons:stripe" />
                  <span>{{ t('migration.paymentCustomers.stripeResults') }}</span>
                </div>
              </template>

              <div class="space-y-2 max-h-96 overflow-y-auto">
                <div
                  v-for="item in result.data.stripeResults"
                  :key="item.userId"
                  class="flex items-center justify-between p-2 rounded border"
                >
                  <span class="text-sm font-mono">{{ item.userId }}</span>
                  <div class="flex items-center gap-2">
                    <UBadge
                      :color="getStatusColor(item.status)"
                      :label="t(`migration.paymentCustomers.status.${item.status}`)"
                    />
                    <span
                      v-if="item.message"
                      class="text-xs text-gray-500 dark:text-gray-400 max-w-32 truncate"
                      :title="item.message"
                    >
                      {{ item.message }}
                    </span>
                  </div>
                </div>
              </div>
            </UCard>

            <!-- Polar Results -->
            <UCard v-if="result.data.polarResults.length > 0">
              <template #header>
                <div class="flex items-center gap-2">
                  <Icon name="lucide:zap" />
                  <span>{{ t('migration.paymentCustomers.polarResults') }}</span>
                </div>
              </template>

              <div class="space-y-2 max-h-96 overflow-y-auto">
                <div
                  v-for="item in result.data.polarResults"
                  :key="item.userId"
                  class="flex items-center justify-between p-2 rounded border"
                >
                  <span class="text-sm font-mono">{{ item.userId }}</span>
                  <div class="flex items-center gap-2">
                    <UBadge
                      :color="getStatusColor(item.status)"
                      :label="t(`migration.paymentCustomers.status.${item.status}`)"
                    />
                    <span
                      v-if="item.message"
                      class="text-xs text-gray-500 dark:text-gray-400 max-w-32 truncate"
                      :title="item.message"
                    >
                      {{ item.message }}
                    </span>
                  </div>
                </div>
              </div>
            </UCard>
          </div>
        </div>
      </div>
    </div>
  </NuxtLayout>
</template>



================================================
FILE: app/pages/admin/subscription/i18n.json
================================================
{
  "en": {
    "subscription": {
      "title": "Subscription Management",
      "plan": "Plan",
      "stripeCustomerId": "Customer ID",
      "status": {
        "incomplete": "Incomplete",
        "incomplete_expired": "Incomplete Expired",
        "trialing": "Trial",
        "active": "Active",
        "paused": "Paused",
        "canceled": "Canceled",
        "pastDue": "Past Due",
        "unpaid": "Unpaid"
      },
      "period": "Billing Period",
      "seats": "Seats"
    }
  },
  "zh-CN": {
    "subscription": {
      "title": "订阅管理",
      "plan": "套餐",
      "stripeCustomerId": "客户 ID",
      "status": {
        "incomplete": "未完成",
        "incomplete_expired": "未完成已过期",
        "trialing": "试用中",
        "active": "有效",
        "paused": "已暂停",
        "canceled": "已取消",
        "pastDue": "已逾期",
        "unpaid": "未支付"
      },
      "period": "计费周期",
      "seats": "席位数"
    }
  },
  "ja": {
    "subscription": {
      "title": "サブスクリプション管理",
      "plan": "プラン",
      "stripeCustomerId": "顧客 ID",
      "status": {
        "incomplete": "不完全",
        "incomplete_expired": "不完全期限切れ",
        "trialing": "試用中",
        "active": "有効",
        "paused": "一時停止",
        "canceled": "キャンセル",
        "pastDue": "期限切れ",
        "unpaid": "未払い"
      },
      "period": "課金期間",
      "seats": "シート数"
    }
  },
  "fr": {
    "subscription": {
      "title": "Gestion des abonnements",
      "plan": "Plan",
      "stripeCustomerId": "ID Client",
      "status": {
        "incomplete": "Incomplet",
        "incomplete_expired": "Incomplet expiré",
        "trialing": "Essai",
        "active": "Actif",
        "paused": "En pause",
        "canceled": "Annulé",
        "pastDue": "En retard",
        "unpaid": "Non payé"
      },
      "period": "Période de facturation",
      "seats": "Sièges"
    }
  }
}



================================================
FILE: app/pages/admin/subscription/index.vue
================================================
<i18n src="./i18n.json"></i18n>

<script setup lang="ts">
import type { Subscription } from '@better-auth/stripe'

const { t } = useI18n()

const filters: AdminTableFilter[] = reactive([
  {
    name: t('global.page.status'),
    field: 'status',
    type: 'tabs',
    items: [
      { label: t('global.page.all'), id: '' },
      { label: t('subscription.status.active'), id: 'active' },
      { label: t('subscription.status.trialing'), id: 'trialing' },
      { label: t('subscription.status.incomplete'), id: 'incomplete' },
      { label: t('subscription.status.incomplete_expired'), id: 'incomplete_expired' },
      { label: t('subscription.status.paused'), id: 'paused' },
      { label: t('subscription.status.canceled'), id: 'canceled' },
      { label: t('subscription.status.pastDue'), id: 'past_due' },
      { label: t('subscription.status.unpaid'), id: 'unpaid' }
    ],
    value: ''
  }
])

const columns: AdminTableColumn<Subscription>[] = [
  {
    accessorKey: 'id',
    header: 'ID'
  },
  {
    accessorKey: 'stripeCustomerId',
    header: t('subscription.stripeCustomerId')
  },
  {
    accessorKey: 'plan',
    header: t('subscription.plan')
  },
  {
    accessorKey: 'status',
    header: t('global.page.status')
  },
  {
    accessorKey: 'period',
    header: t('subscription.period')
  },
  {
    accessorKey: 'seats',
    header: t('subscription.seats')
  }
  // {
  //   accessorKey: 'createdAt',
  //   header: t('global.page.createdAt'),
  //   cell: dateColumn
  // },
]

const getStatusColor = (status: string): 'primary' | 'success' | 'info' | 'warning' | 'error' | 'neutral' => {
  switch (status) {
    case 'active':
      return 'success'
    case 'trialing':
      return 'info'
    case 'paused':
    case 'incomplete':
    case 'incomplete_expired':
      return 'warning'
    case 'canceled':
    case 'past_due':
    case 'unpaid':
      return 'error'
    default:
      return 'neutral'
  }
}

const { data: statusCount } = await useFetch<ColumnCount[]>('/api/admin/count/subscription/status')
statusCount.value?.forEach((item) => {
  const status = (filters[0] as FilterTabs).items?.find(status => status.id === item.column)
  if (status) {
    status.count = item.count
  }
})

const fetchData: FetchDataFn<Subscription> = async ({ page, limit, sort, filter }) => {
  const result = await $fetch<PageData<Subscription>>('/api/admin/list/subscription', {
    query: {
      page,
      limit,
      sort: JSON.stringify(sort.map((item) => {
        return [item.field, item.order]
      })),
      filter: JSON.stringify(filter)
    }
  })
  return {
    data: result.data,
    total: result.total
  }
}
</script>

<template>
  <NuxtLayout name="admin">
    <AdminTable
      ref="table"
      :columns="columns"
      :filters="filters"
      :fetch-data="fetchData"
    >
      <template #status-cell="{ row: { original } }">
        <UBadge
          :color="getStatusColor(original.status)"
          :label="t(`subscription.status.${original.status.replace('_', '')}`)"
        />
      </template>
      <template #period-cell="{ row: { original } }">
        <span v-if="original.periodStart && original.periodEnd">
          {{ formatToDay(original.periodStart) }} ~ {{ formatToDay(original.periodEnd) }}
        </span>
      </template>
    </AdminTable>
  </NuxtLayout>
</template>



================================================
FILE: app/pages/admin/user/i18n.json
================================================
{
  "en": {
    "user": {
      "title": "User Management",
      "columns": {
        "avatar": "Avatar",
        "email": "Email",
        "role": "Role"
      },
      "status": {
        "banned": "Banned",
        "verified": "Verified",
        "unverified": "Unverified"
      },
      "actions": {
        "createUser": "Create User",
        "ban": "Ban",
        "unban": "Unban"
      },
      "form": {
        "email": "Email",
        "password": "Password",
        "role": "Role"
      },
      "validation": {
        "nameMin": "Name must be at least {n} characters",
        "emailInvalid": "Invalid email address",
        "passwordMin": "Password must be at least {n} characters"
      },
      "roles": {
        "user": "User",
        "admin": "Administrator"
      },
      "modals": {
        "createUser": "Create New User",
        "ban": {
          "title": "Ban User",
          "reason": "Ban Reason",
          "reasonPlaceholder": "Enter reason for banning user",
          "period": "Ban Period",
          "periods": {
            "permanent": "Permanent",
            "1_day": "1 Day",
            "7_days": "7 Days",
            "30_days": "30 Days"
          },
          "submit": "Ban User"
        }
      }
    }
  },
  "zh-CN": {
    "user": {
      "title": "用户管理",
      "columns": {
        "avatar": "头像",
        "email": "邮箱",
        "role": "角色"
      },
      "status": {
        "banned": "已封禁",
        "verified": "已验证",
        "unverified": "未验证"
      },
      "actions": {
        "createUser": "创建用户",
        "ban": "封禁",
        "unban": "解封"
      },
      "form": {
        "email": "邮箱",
        "password": "密码",
        "role": "角色"
      },
      "validation": {
        "nameMin": "名称至少需要 {n} 个字符",
        "emailInvalid": "无效的邮箱地址",
        "passwordMin": "密码至少需要 {n} 个字符"
      },
      "roles": {
        "user": "普通用户",
        "admin": "管理员"
      },
      "modals": {
        "createUser": "创建新用户",
        "ban": {
          "title": "封禁用户",
          "reason": "封禁原因",
          "reasonPlaceholder": "请输入封禁用户的原因",
          "period": "封禁期限",
          "periods": {
            "permanent": "永久",
            "1_day": "1天",
            "7_days": "7天",
            "30_days": "30天"
          },
          "submit": "封禁用户"
        }
      }
    }
  },
  "ja": {
    "user": {
      "title": "ユーザー管理",
      "columns": {
        "avatar": "アバター",
        "email": "メール",
        "role": "役割"
      },
      "status": {
        "banned": "禁止",
        "verified": "確認済み",
        "unverified": "未確認"
      },
      "actions": {
        "createUser": "ユーザー作成",
        "ban": "禁止",
        "unban": "解除"
      },
      "form": {
        "email": "メールアドレス",
        "password": "パスワード",
        "role": "役割"
      },
      "validation": {
        "nameMin": "名前は少なくとも {n} 文字必要です",
        "emailInvalid": "無効なメールアドレス",
        "passwordMin": "パスワードは少なくとも {n} 文字必要です"
      },
      "roles": {
        "user": "ユーザー",
        "admin": "管理者"
      },
      "modals": {
        "createUser": "新規ユーザー作成",
        "ban": {
          "title": "ユーザーをバン",
          "reason": "バンの理由",
          "reasonPlaceholder": "ユーザーをバンする理由を入力してください",
          "period": "バン期間",
          "periods": {
            "permanent": "永久",
            "1_day": "1日",
            "7_days": "7日間",
            "30_days": "30日間"
          },
          "submit": "ユーザーをバン"
        }
      }
    }
  },
  "fr": {
    "user": {
      "title": "Gestion des utilisateurs",
      "columns": {
        "avatar": "Avatar",
        "email": "Email",
        "role": "Rôle"
      },
      "status": {
        "banned": "Banni",
        "verified": "Vérifié",
        "unverified": "Non vérifié"
      },
      "actions": {
        "createUser": "Créer un utilisateur",
        "ban": "Bannir",
        "unban": "Débannir"
      },
      "form": {
        "email": "Email",
        "password": "Mot de passe",
        "role": "Rôle"
      },
      "validation": {
        "nameMin": "Le nom doit contenir au moins {n} caractères",
        "emailInvalid": "Adresse e-mail invalide",
        "passwordMin": "Le mot de passe doit contenir au moins {n} caractères"
      },
      "roles": {
        "user": "Utilisateur",
        "admin": "Administrateur"
      },
      "modals": {
        "createUser": "Créer un nouvel utilisateur",
        "ban": {
          "title": "Bannir l'utilisateur",
          "reason": "Raison du bannissement",
          "reasonPlaceholder": "Entrez la raison du bannissement",
          "period": "Période de bannissement",
          "periods": {
            "permanent": "Permanent",
            "1_day": "1 jour",
            "7_days": "7 jours",
            "30_days": "30 jours"
          },
          "submit": "Bannir l'utilisateur"
        }
      }
    }
  }
}



================================================
FILE: app/pages/admin/user/index.vue
================================================
<i18n src="./i18n.json"></i18n>

<script setup lang="ts">
import BanUserModal from './components/BanUserModal.vue'
import CreateUserModal from './components/CreateUserModal.vue'

const { t } = useI18n()
const { client } = useAuth()
const isUserModalOpen = ref(false)
const isBanModalOpen = ref(false)
const selectedUserId = ref('')

const filters: AdminTableFilter[] = reactive([
  {
    name: t('global.page.name'),
    field: 'name',
    type: 'input',
    value: undefined
  },
  {
    name: t('user.columns.role'),
    field: 'role',
    type: 'checkbox',
    items: [
      { label: t('user.roles.user'), id: 'user', count: 0 },
      { label: t('user.roles.admin'), id: 'admin', count: 0 }
    ],
    value: []
  },
  {
    name: t('global.page.createdAt'),
    field: 'createdAt',
    type: 'daterange',
    value: { start: undefined, end: undefined }
  }
])

const { refresh } = useAdminTable()

const getActionItems = (row: Row<User>) => {
  const user = row.original
  return [
    {
      type: 'label',
      label: t('global.page.actions')
    },
    {
      type: 'separator'
    },
    {
      label: user.banned ? t('user.actions.unban') : t('user.actions.ban'),
      icon: 'i-lucide-ban',
      color: user.banned ? 'success' : 'error',
      async onSelect() {
        if (user.banned) {
          const result = await client.admin.unbanUser({
            userId: user.id
          })
          if (result.data?.user) {
            refresh()
          }
        } else {
          selectedUserId.value = user.id
          isBanModalOpen.value = true
        }
      }
    },
    {
      label: t('global.page.delete'),
      icon: 'i-lucide-trash',
      color: 'error',
      async onSelect() {
        const removeResult = await client.admin.removeUser({
          userId: user.id
        })
        if (removeResult.data?.success) {
          refresh()
        } else {
          console.error(removeResult.error)
        }
      }
    }
  ]
}

const getRoleDropdownItems = (original: User) => {
  const roles = ['user', 'admin'] as const
  return roles.map((role) => {
    return {
      label: t(`user.roles.${role}`),
      type: 'checkbox' as const,
      checked: original.role === role,
      onUpdateChecked: async () => {
        const result = await client.admin.setRole({
          userId: original.id,
          role
        })
        if (result.data?.user) {
          refresh()
        } else {
          console.error(result.error)
        }
      }
    }
  })
}

const columns: AdminTableColumn<User>[] = [
  {
    accessorKey: 'id',
    header: 'ID'
  },
  {
    accessorKey: 'image',
    header: t('user.columns.avatar'),
    cell: avatarColumn
  },
  {
    accessorKey: 'name',
    header: t('global.page.name')
  },
  {
    accessorKey: 'email',
    header: t('user.columns.email')
  },
  {
    accessorKey: 'role',
    header: t('user.columns.role')
  },
  {
    accessorKey: 'status',
    header: t('global.page.status')
  },
  {
    accessorKey: 'createdAt',
    header: t('global.page.createdAt'),
    cell: dateColumn
  },
  {
    id: 'actions',
    cell: ({ row }) => actionColumn(row, getActionItems)
  }
]

const fetchRoleCount = async (filter: FilterCondition[]) => {
  const statusCount = await $fetch<ColumnCount[]>('/api/admin/count/user/role', {
    query: {
      filter: JSON.stringify(filter)
    }
  })
  const roleFilter = filters[1] as FilterCheckbox
  roleFilter.items.forEach((item) => {
    const status = statusCount.find(status => status.column === item.id)
    item.count = status ? status.count : 0
  })
}

const fetchData: FetchDataFn<User> = async ({ page, limit, sort, filter }) => {
  fetchRoleCount(filter)
  const result = await $fetch<PageData<User>>('/api/admin/list/user', {
    query: {
      page,
      limit,
      sort: JSON.stringify(sort.map((item) => {
        return [item.field, item.order]
      })),
      filter: JSON.stringify(filter)
    }
  })
  return {
    data: result.data,
    total: result.total
  }
}
</script>

<template>
  <NuxtLayout name="admin">
    <template #navRight>
      <UButton
        color="neutral"
        icon="i-lucide-plus"
        variant="outline"
        @click="isUserModalOpen = true"
      >
        {{ t('user.actions.createUser') }}
      </UButton>
    </template>
    <AdminTable
      ref="table"
      :columns="columns"
      :filters="filters"
      :fetch-data="fetchData"
    >
      <template #role-cell="{ row: { original } }">
        <UDropdownMenu
          :items="getRoleDropdownItems(original)"
          arrow
        >
          <UButton
            :color="original.role === 'admin' ? 'primary' : 'neutral'"
            variant="outline"
            size="xs"
            icon="i-lucide-chevron-down"
            trailing
          >
            {{ t(`user.roles.${original.role}`) }}
          </UButton>
        </UDropdownMenu>
      </template>
      <template #status-cell="{ row: { original } }">
        <UBadge
          :color="original.banned
            ? 'error'
            : (original.emailVerified ? 'success' : 'warning')"
          :label="original.banned
            ? t('user.status.banned')
            : (original.emailVerified
              ? t('user.status.verified')
              : t('user.status.unverified'))"
        />
      </template>
    </AdminTable>
    <CreateUserModal
      v-model:open="isUserModalOpen"
      :t="t"
      @created="refresh"
    />
    <BanUserModal
      v-model:open="isBanModalOpen"
      :user-id="selectedUserId"
      :t="t"
      @banned="refresh"
    />
  </NuxtLayout>
</template>



================================================
FILE: app/pages/admin/user/components/BanUserModal.vue
================================================
<script setup lang="ts">
const { userId, t } = defineProps<{
  userId: string
  t: TranFunction
}>()

const emit = defineEmits<{
  banned: []
  cancel: []
}>()

const open = defineModel('open', { default: false })

const state = reactive({
  banReason: '',
  banExpiresIn: -1 as number | undefined
})

const schema = z.object({
  banReason: z.string().optional(),
  banExpiresIn: z.number().optional()
})
type Schema = zodOutput<typeof schema>

const { client } = useAuth()

const banPeriods = [
  { value: -1, label: 'permanent' },
  { value: 60 * 60 * 24, label: '1_day' },
  { value: 60 * 60 * 24 * 7, label: '7_days' },
  { value: 60 * 60 * 24 * 30, label: '30_days' }
].map((item) => {
  return {
    ...item,
    label: t(`user.modals.ban.periods.${item.label}`)
  }
})

async function onSubmit({ data }: FormSubmitEvent<Schema>) {
  const result = await client.admin.banUser({
    userId,
    banReason: data.banReason,
    banExpiresIn: data.banExpiresIn == -1 ? undefined : data.banExpiresIn
  })
  if (result.data?.user) {
    open.value = false
    emit('banned')
  }
}

const onCancel = () => {
  open.value = false
  emit('cancel')
}
</script>

<template>
  <UModal
    v-model:open="open"
    :close="true"
    :title="t('user.modals.ban.title')"
  >
    <template #body>
      <UForm
        :schema="schema"
        :state="state"
        class="space-y-4"
        @submit="onSubmit"
      >
        <UFormField
          :label="t('user.modals.ban.period')"
          name="banExpiresIn"
        >
          <USelect
            v-model="state.banExpiresIn"
            :items="banPeriods"
            class="w-full"
          />
        </UFormField>
        <UFormField
          :label="t('user.modals.ban.reason')"
          name="banReason"
        >
          <UTextarea
            v-model="state.banReason"
            :placeholder="t('user.modals.ban.reasonPlaceholder')"
            class="w-full"
          />
        </UFormField>

        <div class="flex justify-end gap-2">
          <UButton
            color="neutral"
            variant="outline"
            @click="onCancel"
          >
            {{ t('global.page.cancel') }}
          </UButton>
          <UButton
            type="submit"
            color="error"
          >
            {{ t('user.modals.ban.submit') }}
          </UButton>
        </div>
      </UForm>
    </template>
  </UModal>
</template>



================================================
FILE: app/pages/admin/user/components/CreateUserModal.vue
================================================
<script setup lang="ts">
const { t } = defineProps<{
  t: TranFunction
}>()

const emit = defineEmits<{
  created: []
  cancel: []
}>()

const open = defineModel('open', { default: false })
const { client } = useAuth()

const schema = z.object({
  name: z.string().min(4, t('user.validation.nameMin', { n: 4 })),
  email: z.email(t('user.validation.emailInvalid')),
  password: z.string().min(8, t('user.validation.passwordMin', { n: 8 })),
  role: z.enum(['user', 'admin'])
})
type Schema = zodOutput<typeof schema>

const state = reactive({
  name: '',
  email: '',
  password: '',
  role: 'user' as const
})

async function onSubmit({ data }: FormSubmitEvent<Schema>) {
  const res = await client.admin.createUser({
    name: data.name,
    email: data.email,
    password: data.password,
    role: data.role
  })
  if (res) {
    open.value = false
    emit('created')
  }
}

const onCancel = () => {
  open.value = false
  emit('cancel')
}
</script>

<template>
  <UModal
    v-model:open="open"
    :close="true"
    :title="t('user.modals.createUser')"
  >
    <template #body>
      <UForm
        :schema="schema"
        :state="state"
        class="space-y-4"
        @submit="onSubmit"
      >
        <UFormField
          :label="t('global.page.name')"
          name="name"
        >
          <UInput
            v-model="state.name"
            class="w-full"
          />
        </UFormField>

        <UFormField
          :label="t('user.form.email')"
          name="email"
        >
          <UInput
            v-model="state.email"
            class="w-full"
          />
        </UFormField>

        <UFormField
          :label="t('user.form.password')"
          name="password"
        >
          <UInput
            v-model="state.password"
            type="password"
            class="w-full"
          />
        </UFormField>

        <UFormField
          :label="t('user.form.role')"
          name="role"
        >
          <USelect
            v-model="state.role"
            class="w-full"
            :items="[
              { label: t('user.roles.user'), value: 'user' },
              { label: t('user.roles.admin'), value: 'admin' }
            ]"
          />
        </UFormField>

        <div class="flex justify-end w-full gap-4">
          <UButton
            color="neutral"
            variant="soft"
            @click="onCancel"
          >
            {{ t('global.page.cancel') }}
          </UButton>
          <UButton
            type="submit"
            color="primary"
          >
            {{ t('global.page.create') }}
          </UButton>
        </div>
      </UForm>
    </template>
  </UModal>
</template>



================================================
FILE: app/pages/forgot-password/i18n.json
================================================
{
  "en": {
    "forgotPassword": {
      "title": "Reset Password",
      "description": "Enter your email address and we'll send you instructions to reset your password.",
      "email": "Email",
      "emailPlaceholder": "Enter your email address",
      "submit": "Send Instructions",
      "backToSignIn": "Back to Sign In",
      "success": "Reset instructions have been sent to your email",
      "errors": {
        "invalidEmail": "Invalid email address"
      }
    }
  },
  "zh-CN": {
    "forgotPassword": {
      "title": "重置密码",
      "description": "请输入您的邮箱地址，我们将向您发送重置密码的说明。",
      "email": "邮箱",
      "emailPlaceholder": "请输入邮箱地址",
      "submit": "发送说明",
      "backToSignIn": "返回登录",
      "success": "重置说明已发送至您的邮箱",
      "errors": {
        "invalidEmail": "无效的邮箱地址"
      }
    }
  },
  "ja": {
    "forgotPassword": {
      "title": "パスワードのリセット",
      "description": "メールアドレスを入力してください。パスワードをリセットする手順をお送りします。",
      "email": "メールアドレス",
      "emailPlaceholder": "メールアドレスを入力",
      "submit": "手順を送信",
      "backToSignIn": "ログインに戻る",
      "success": "リセット手順をメールに送信しました",
      "errors": {
        "invalidEmail": "無効なメールアドレス"
      }
    }
  },
  "fr": {
    "forgotPassword": {
      "title": "Réinitialiser le mot de passe",
      "description": "Saisissez votre adresse e-mail et nous vous enverrons les instructions pour réinitialiser votre mot de passe.",
      "email": "E-mail",
      "emailPlaceholder": "Saisissez votre adresse e-mail",
      "submit": "Envoyer les instructions",
      "backToSignIn": "Retour à la connexion",
      "success": "Les instructions de réinitialisation ont été envoyées à votre e-mail",
      "errors": {
        "invalidEmail": "Adresse e-mail invalide"
      }
    }
  }
}



================================================
FILE: app/pages/forgot-password/index.vue
================================================
<i18n src="./i18n.json"></i18n>

<script setup lang="ts">
definePageMeta({
  auth: {
    only: 'guest'
  }
})

const { t } = useI18n()
useHead({
  title: t('forgotPassword.title')
})

const auth = useAuth()
const toast = useToast()
const localePath = useLocalePath()

const schema = z.object({
  email: z.email(t('forgotPassword.errors.invalidEmail'))
})

type Schema = zodOutput<typeof schema>

const state = reactive<Partial<Schema>>({
  email: undefined
})

const loading = ref(false)

async function onSubmit(event: FormSubmitEvent<Schema>) {
  if (loading.value)
    return

  loading.value = true
  const { error } = await auth.forgetPassword({
    email: event.data.email,
    redirectTo: localePath('/reset-password')
  })

  if (error) {
    toast.add({
      title: error.message || error.statusText,
      color: 'error'
    })
  }
  else {
    toast.add({
      title: t('forgotPassword.success'),
      color: 'success'
    })
  }
  loading.value = false
}
</script>

<template>
  <UContainer class="flex items-center justify-center sm:p-4 sm:min-w-160">
    <UCard class="w-full max-w-md">
      <template #header>
        <div class="text-center p-4">
          <h1 class="text-xl font-semibold">
            {{ t('forgotPassword.title') }}
          </h1>
          <p class="text-sm text-gray-500 dark:text-gray-400 mt-2">
            {{ t('forgotPassword.description') }}
          </p>
        </div>
      </template>

      <div class="space-y-4">
        <UForm
          :schema="schema"
          :state="state"
          class="space-y-4"
          @submit="onSubmit"
        >
          <UFormField
            :label="t('forgotPassword.email')"
            name="email"
            required
          >
            <UInput
              v-model="state.email"
              type="email"
              class="w-full"
              :placeholder="t('forgotPassword.emailPlaceholder')"
            />
          </UFormField>

          <UButton
            type="submit"
            color="primary"
            block
            :loading="loading"
          >
            {{ t('forgotPassword.submit') }}
          </UButton>
        </UForm>

        <div class="text-center text-sm">
          <UButton
            variant="link"
            color="primary"
            :to="localePath('/signin')"
          >
            {{ t('forgotPassword.backToSignIn') }}
          </UButton>
        </div>
      </div>
    </UCard>
  </UContainer>
</template>



================================================
FILE: app/pages/pricing/i18n.json
================================================
{
  "en": {
    "pricing": {
      "title": "Simple, transparent pricing",
      "subtitle": "Choose the plan that suits your needs",
      "monthly": "Monthly",
      "yearly": "Yearly",
      "savePercent": "Save {percent}%",
      "popular": "Popular",
      "free": {
        "name": "Free",
        "description": "Perfect for getting started",
        "price": "Free",
        "period": "forever",
        "feature1": "Basic features",
        "feature2": "Community support"
      },
      "pro": {
        "name": "Pro",
        "description": "For growing businesses",
        "price": "${price}",
        "period": "per month",
        "yearPeriod": "per year",
        "feature1": "All features",
        "feature2": "Priority support"
      },
      "enterprise": {
        "name": "Enterprise",
        "description": "For large organizations",
        "price": "Custom",
        "period": "contact us",
        "feature1": "Everything in Pro",
        "feature2": "Dedicated support",
        "feature3": "Custom deployment"
      },
      "features": {
        "title": "Features included:"
      },
      "cta": {
        "free": "Get Started",
        "pro": "Start Pro Trial",
        "enterprise": "Contact Sales"
      }
    }
  },
  "zh-CN": {
    "pricing": {
      "title": "简单透明的定价",
      "subtitle": "选择最适合您需求的方案",
      "monthly": "按月付费",
      "yearly": "按年付费",
      "savePercent": "节省 {percent}%",
      "popular": "热门",
      "free": {
        "name": "免费版",
        "description": "完美的入门选择",
        "price": "免费",
        "period": "永久",
        "feature1": "基础功能",
        "feature2": "社区支持"
      },
      "pro": {
        "name": "专业版",
        "description": "适合成长中的企业",
        "price": "${price}",
        "period": "每月",
        "yearPeriod": "每年",
        "feature1": "所有功能",
        "feature2": "优先支持"
      },
      "enterprise": {
        "name": "企业版",
        "description": "适合大型组织",
        "price": "定制",
        "period": "联系我们",
        "feature1": "包含专业版所有功能",
        "feature2": "专属支持",
        "feature3": "自定义部署"
      },
      "features": {
        "title": "包含功能："
      },
      "cta": {
        "free": "立即开始",
        "pro": "开始专业版试用",
        "enterprise": "联系销售"
      }
    }
  },
  "ja": {
    "pricing": {
      "title": "シンプルで透明な料金体系",
      "subtitle": "ニーズに合ったプランを選択",
      "monthly": "月払い",
      "yearly": "年払い",
      "savePercent": "{percent}%お得",
      "popular": "人気",
      "free": {
        "name": "無料プラン",
        "description": "始めるのに最適",
        "price": "無料",
        "period": "永久",
        "feature1": "基本機能",
        "feature2": "コミュニティサポート"
      },
      "pro": {
        "name": "プロプラン",
        "description": "成長中の企業向け",
        "price": "${price}",
        "period": "月額",
        "yearPeriod": "年額",
        "feature1": "全機能",
        "feature2": "優先サポート"
      },
      "enterprise": {
        "name": "エンタープライズ",
        "description": "大規模組織向け",
        "price": "カスタム",
        "period": "お問い合わせ",
        "feature1": "プロプランの全機能",
        "feature2": "専任サポート",
        "feature3": "カスタム導入"
      },
      "features": {
        "title": "含まれる機能："
      },
      "cta": {
        "free": "今すぐ始める",
        "pro": "プロ版を試す",
        "enterprise": "営業に問い合わせ"
      }
    }
  },
  "fr": {
    "pricing": {
      "title": "Tarification simple et transparente",
      "subtitle": "Choisissez le plan qui vous convient",
      "monthly": "Mensuel",
      "yearly": "Annuel",
      "savePercent": "Économisez {percent}%",
      "popular": "Populaire",
      "free": {
        "name": "Gratuit",
        "description": "Parfait pour commencer",
        "price": "Gratuit",
        "period": "pour toujours",
        "feature1": "Fonctionnalités de base",
        "feature2": "Support communautaire"
      },
      "pro": {
        "name": "Pro",
        "description": "Pour les entreprises en croissance",
        "price": "${price}",
        "period": "par mois",
        "yearPeriod": "par an",
        "feature1": "Toutes les fonctionnalités",
        "feature2": "Support prioritaire"
      },
      "enterprise": {
        "name": "Entreprise",
        "description": "Pour les grandes organisations",
        "price": "Sur mesure",
        "period": "contactez-nous",
        "feature1": "Tout ce qui est inclus dans Pro",
        "feature2": "Support dédié",
        "feature3": "Déploiement personnalisé"
      },
      "features": {
        "title": "Fonctionnalités incluses :"
      },
      "cta": {
        "free": "Commencer",
        "pro": "Essayer Pro",
        "enterprise": "Contacter les ventes"
      }
    }
  }
}



================================================
FILE: app/pages/pricing/index.vue
================================================
<i18n src="./i18n.json"></i18n>

<script setup lang="ts">
definePageMeta({
  auth: false,
  layout: false
})
const { t } = useI18n()
const { loggedIn, subscription, payment, client } = useAuth()
const localePath = useLocalePath()
const runtimeConfig = useRuntimeConfig()
const billingPeriod = ref('monthly')

const plans = [
  {
    name: t('pricing.free.name'),
    description: t('pricing.free.description'),
    price: t('pricing.free.price'),
    period: t('pricing.free.period'),
    features: [
      t('pricing.free.feature1'),
      t('pricing.free.feature2')
    ],
    cta: t('pricing.cta.free'),
    color: 'neutral' as const,
    to: runtimeConfig.public.appRepo
  },
  {
    name: t('pricing.pro.name'),
    description: t('pricing.pro.description'),
    price: t('pricing.pro.price', { price: 10 }),
    yearPrice: t('pricing.pro.price', { price: 100 }),
    period: t('pricing.pro.period'),
    yearPeriod: t('pricing.pro.yearPeriod'),
    features: [
      t('pricing.pro.feature1'),
      t('pricing.pro.feature2')
    ],
    cta: t('pricing.cta.pro'),
    color: 'primary' as const,
    popular: true,
    click: async () => {
      if (!loggedIn.value) {
        navigateTo(localePath('/signin?redirect=/pricing'))
        return
      }
      if (payment == 'stripe') {
        const result = await subscription.upgrade({
          plan: `pro-${billingPeriod.value}`,
          successUrl: localePath('/'),
          cancelUrl: localePath('/pricing')
        })
        console.log(result)
      } else if (payment == 'polar') {
        const result = await client.checkout({
          slug: `pro-${billingPeriod.value}`
        })
        console.log(result)
      }
    }
  },
  {
    name: t('pricing.enterprise.name'),
    description: t('pricing.enterprise.description'),
    price: t('pricing.enterprise.price'),
    period: t('pricing.enterprise.period'),
    features: [
      t('pricing.enterprise.feature1'),
      t('pricing.enterprise.feature2'),
      t('pricing.enterprise.feature3')
    ],
    cta: t('pricing.cta.enterprise'),
    color: 'neutral' as const,
    to: `mailto:${runtimeConfig.public.appContactEmail}`
  }
]
</script>

<template>
  <NuxtLayout name="default">
    <template #nav-center>
      <SiteNavigation
        mode="desktop"
        class="hidden sm:flex"
      />
    </template>
    <template #nav-right>
      <div class="flex items-center gap-2">
        <UserNavigation />
        <SiteNavigation
          mode="mobile"
          class="flex sm:hidden"
        />
      </div>
    </template>
    <UContainer class="space-y-6 pt-8 pb-6">
      <!-- Header -->
      <div class="text-center space-y-2">
        <h1 class="text-4xl font-bold">
          {{ t('pricing.title') }}
        </h1>
        <p class="text-lg text-gray-500 dark:text-gray-400">
          {{ t('pricing.subtitle') }}
        </p>

        <!-- Billing toggle -->
        <div class="flex items-center justify-center gap-2 pt-2">
          <URadioGroup
            v-model:model-value="billingPeriod"
            orientation="horizontal"
            size="lg"
            :items="[
              { label: t('pricing.monthly'), value: 'monthly' },
              { label: t('pricing.yearly'), value: 'yearly' }
            ]"
          />
        </div>
      </div>
      <!-- Pricing cards -->
      <div class="grid grid-cols-1 lg:grid-cols-3 gap-8">
        <div
          v-for="plan in plans"
          :key="plan.name"
          class="relative"
        >
          <UCard
            class="h-full flex flex-col"
            :class="[
              plan.popular && 'border-primary dark:border-primary'
            ]"
          >
            <div class="flex-1 space-y-6 w-[300px]">
              <div class="space-y-2">
                <h2 class="text-2xl font-bold">
                  {{ plan.name }}
                </h2>
                <p class="text-gray-500 dark:text-gray-400">
                  {{ plan.description }}
                </p>
              </div>

              <div class="space-y-1">
                <div class="text-3xl font-bold">
                  {{ billingPeriod === 'yearly' ? plan.yearPrice || plan.price : plan.price }}
                </div>
                <div class="text-sm text-gray-500 dark:text-gray-400">
                  {{ billingPeriod === 'yearly' ? plan.yearPeriod || plan.period : plan.period }}
                </div>
              </div>

              <USeparator />

              <div class="space-y-4">
                <p class="font-medium">
                  {{ t('pricing.features.title') }}
                </p>
                <ul class="space-y-3">
                  <li
                    v-for="(feature, index) in plan.features"
                    :key="index"
                    class="flex items-start gap-2"
                  >
                    <UIcon
                      name="lucide:check"
                      class="flex-shrink-0 mt-1 text-green-500"
                    />
                    <span>{{ feature }}</span>
                  </li>
                </ul>
              </div>
            </div>

            <template #footer>
              <UButton
                :color="plan.color"
                :to="plan.to"
                variant="solid"
                class="w-full justify-center"
                @click="plan.click"
              >
                {{ plan.cta }}
              </UButton>
            </template>
          </UCard>
        </div>
      </div>
    </UContainer>
  </NuxtLayout>
</template>



================================================
FILE: app/pages/profile/i18n.json
================================================
{
  "en": {
    "profile": {
      "back": "Back",
      "anonymousUser": "Anonymous User",
      "role": "Role",
      "emailVerified": "Email Verified",
      "verified": "Verified",
      "notVerified": "Not Verified",
      "created": "Created",
      "lastUpdated": "Last Updated",
      "sessionInfo": "Session Information",
      "ipAddress": "IP Address",
      "expires": "Expires",
      "userAgent": "User Agent",
      "connectedAccounts": "Connected Accounts",
      "linkedGithub": "Linked with GitHub",
      "linkGithub": "Link account with GitHub"
    }
  },
  "zh-CN": {
    "profile": {
      "back": "返回",
      "anonymousUser": "匿名用户",
      "role": "角色",
      "emailVerified": "邮箱验证",
      "verified": "已验证",
      "notVerified": "未验证",
      "created": "创建时间",
      "lastUpdated": "更新时间",
      "sessionInfo": "会话信息",
      "ipAddress": "IP地址",
      "expires": "过期时间",
      "userAgent": "用户代理",
      "connectedAccounts": "关联账号",
      "linkedGithub": "已关联 GitHub",
      "linkGithub": "关联 GitHub 账号"
    }
  },
  "ja": {
    "profile": {
      "back": "戻る",
      "anonymousUser": "匿名ユーザー",
      "role": "役割",
      "emailVerified": "メール確認",
      "verified": "確認済み",
      "notVerified": "未確認",
      "created": "作成日時",
      "lastUpdated": "更新日時",
      "sessionInfo": "セッション情報",
      "ipAddress": "IPアドレス",
      "expires": "有効期限",
      "userAgent": "ユーザーエージェント",
      "connectedAccounts": "連携アカウント",
      "linkedGithub": "GitHub連携済み",
      "linkGithub": "GitHubと連携する"
    }
  },
  "fr": {
    "profile": {
      "back": "Retour",
      "anonymousUser": "Utilisateur Anonyme",
      "role": "Rôle",
      "emailVerified": "Email Vérifié",
      "verified": "Vérifié",
      "notVerified": "Non Vérifié",
      "created": "Créé le",
      "lastUpdated": "Dernière mise à jour",
      "sessionInfo": "Informations de Session",
      "ipAddress": "Adresse IP",
      "expires": "Expire le",
      "userAgent": "Agent Utilisateur",
      "connectedAccounts": "Comptes Connectés",
      "linkedGithub": "Lié à GitHub",
      "linkGithub": "Lier le compte avec GitHub"
    }
  }
}



================================================
FILE: app/pages/profile/index.vue
================================================
<i18n src="./i18n.json"></i18n>

<script setup lang="ts">
const { user, session, client } = useAuth()
const toast = useToast()
const { t } = useI18n()
const localePath = useLocalePath()
const { data: accounts } = await useAsyncData('/accounts', () => client.listAccounts())

function hasProvider(provider: string) {
  return accounts.value?.data?.some(account => account.provider === provider)
}

const error = useRoute().query?.error
onMounted(() => {
  if (error) {
    toast.add({
      color: 'error',
      title: `${error}`
    })
  }
})
</script>

<template>
  <UContainer>
    <div class="space-y-6 pt-6">
      <!-- User Profile Section -->
      <div class="bg-white dark:bg-gray-800 rounded-lg p-6">
        <div class="flex justify-between items-center mb-4">
          <div class="flex items-center gap-4">
            <UAvatar
              v-if="user?.image"
              :src="user.image"
              :alt="user?.name || ''"
              size="lg"
            />
            <div>
              <h1 class="text-2xl font-bold">
                {{ user?.name || t('profile.anonymousUser') }}
              </h1>
              <p class="text-gray-500 dark:text-gray-400">
                {{ user?.email }}
              </p>
            </div>
          </div>
          <UButton
            :to="localePath('/')"
            variant="outline"
            color="neutral"
            icon="i-lucide-arrow-left"
          >
            {{ t('profile.back') }}
          </UButton>
        </div>

        <div class="grid gap-4 md:grid-cols-2">
          <div class="space-y-2">
            <p class="flex justify-between">
              <span class="text-gray-500 dark:text-gray-400">{{ t('profile.role') }}:</span>
              <UBadge :color="user?.role === 'admin' ? 'primary' : 'neutral'">
                {{ user?.role }}
              </UBadge>
            </p>
            <p class="flex justify-between">
              <span class="text-gray-500 dark:text-gray-400">{{ t('profile.emailVerified') }}:</span>
              <UBadge :color="user?.emailVerified ? 'success' : 'warning'">
                {{ user?.emailVerified ? t('profile.verified') : t('profile.notVerified') }}
              </UBadge>
            </p>
          </div>
          <div class="space-y-2">
            <p class="flex justify-between">
              <span class="text-gray-500 dark:text-gray-400">{{ t('profile.created') }}:</span>
              <span>{{ formatDate(user?.createdAt) }}</span>
            </p>
            <p class="flex justify-between">
              <span class="text-gray-500 dark:text-gray-400">{{ t('profile.lastUpdated') }}:</span>
              <span>{{ formatDate(user?.updatedAt) }}</span>
            </p>
          </div>
        </div>
      </div>

      <!-- Session Information -->
      <div class="bg-white dark:bg-gray-800 rounded-lg p-6">
        <h2 class="text-xl font-bold mb-4">
          {{ t('profile.sessionInfo') }}
        </h2>
        <div class="space-y-2">
          <p class="flex justify-between">
            <span class="text-gray-500 dark:text-gray-400">{{ t('profile.ipAddress') }}:</span>
            <span>{{ session?.ipAddress }}</span>
          </p>
          <p class="flex justify-between">
            <span class="text-gray-500 dark:text-gray-400">{{ t('profile.expires') }}:</span>
            <span>{{ formatDate(session?.expiresAt) }}</span>
          </p>
          <p class="text-gray-500 dark:text-gray-400">
            {{ t('profile.userAgent') }}:
          </p>
          <p class="text-sm break-all">
            {{ session?.userAgent }}
          </p>
        </div>
      </div>

      <!-- Connected Accounts -->
      <div class="bg-white dark:bg-gray-800 rounded-lg p-6">
        <h2 class="text-xl font-bold mb-4">
          {{ t('profile.connectedAccounts') }}
        </h2>
        <div class="flex gap-2">
          <UButton
            v-if="hasProvider('github')"
            color="neutral"
            icon="i-simple-icons-github"
            trailing-icon="i-heroicons-check"
          >
            {{ t('profile.linkedGithub') }}
          </UButton>
          <UButton
            v-else
            color="neutral"
            icon="i-simple-icons-github"
            @click="client.linkSocial({ provider: 'github' })"
          >
            {{ t('profile.linkGithub') }}
          </UButton>
        </div>
      </div>
    </div>
  </UContainer>
</template>



================================================
FILE: app/pages/reset-password/i18n.json
================================================
[Binary file]


================================================
FILE: app/pages/reset-password/index.vue
================================================
<i18n src="./i18n.json"></i18n>

<script setup lang="ts">
definePageMeta({
  auth: {
    only: 'guest'
  }
})

const { t } = useI18n()
useHead({
  title: t('resetPassword.title')
})

const auth = useAuth()
const toast = useToast()
const route = useRoute()
const localePath = useLocalePath()
const runtimeConfig = useRuntimeConfig()

const state = reactive({
  password: undefined as string | undefined,
  confirmPassword: undefined as string | undefined
})

const schema = z.object({
  password: z.string().min(8, t('resetPassword.errors.minLength', { min: 8 })),
  confirmPassword: z.string().min(8, t('resetPassword.errors.minLength', { min: 8 })).refine(val => val === state.password, {
    message: t('resetPassword.errors.passwordMismatch')
  })
})

type Schema = zodOutput<typeof schema>

const loading = ref(false)

async function onSubmit(event: FormSubmitEvent<Schema>) {
  if (loading.value)
    return

  loading.value = true
  const { error } = await auth.resetPassword({
    newPassword: event.data.password,
    token: route.query.token as string
  })

  if (error) {
    toast.add({
      title: error.message,
      color: 'error'
    })
  } else {
    toast.add({
      title: t('resetPassword.success'),
      color: 'success'
    })
    navigateTo(localePath(runtimeConfig.public.auth.redirectGuestTo))
  }
  loading.value = false
}
</script>

<template>
  <UContainer class="flex items-center justify-center sm:p-4 sm:min-w-160">
    <UCard class="w-full max-w-md">
      <template #header>
        <div class="text-center p-4">
          <h1 class="text-xl font-semibold">
            {{ t('resetPassword.title') }}
          </h1>
          <p class="text-sm text-gray-500 dark:text-gray-400 mt-2">
            {{ t('resetPassword.description') }}
          </p>
        </div>
      </template>

      <div class="space-y-4">
        <UForm
          :schema="schema"
          :state="state"
          class="space-y-4"
          @submit="onSubmit"
        >
          <UFormField
            :label="t('resetPassword.password')"
            name="password"
            required
          >
            <UInput
              v-model="state.password"
              type="password"
              class="w-full"
              :placeholder="t('resetPassword.passwordPlaceholder')"
            />
          </UFormField>

          <UFormField
            :label="t('resetPassword.confirmPassword')"
            name="confirmPassword"
            required
          >
            <UInput
              v-model="state.confirmPassword"
              type="password"
              class="w-full"
              :placeholder="t('resetPassword.confirmPasswordPlaceholder')"
            />
          </UFormField>

          <UButton
            type="submit"
            color="primary"
            block
            :loading="loading"
          >
            {{ t('resetPassword.submit') }}
          </UButton>
        </UForm>

        <div class="text-center text-sm">
          <UButton
            variant="link"
            color="primary"
            :to="localePath('/signin')"
          >
            {{ t('resetPassword.backToSignIn') }}
          </UButton>
        </div>
      </div>
    </UCard>
  </UContainer>
</template>



================================================
FILE: app/pages/signin/i18n.json
================================================
{
  "en": {
    "signIn": {
      "welcome": "Welcome to {name}",
      "email": "Email",
      "password": "Password",
      "emailPlaceholder": "Email Address",
      "passwordPlaceholder": "Password",
      "rememberMe": "Remember me",
      "forgotPassword": "Forgot your password?",
      "signIn": "Sign In",
      "noAccount": "Don't have an account?",
      "createAccount": "Create today!",
      "or": "Or",
      "signInSuccess": "Sign in Success",
      "errors": {
        "invalidEmail": "Invalid email address",
        "passwordLength": "Password must be at least {min} characters"
      },
      "emailNotVerified": "Email Not Verified",
      "emailNotVerifiedDesc": "Please verify your email address to continue.",
      "sendEmail": "Send Verification Email",
      "sendEmailSuccess": "Verification email has been sent",
      "sendEmailError": "Failed to send verification email"
    }
  },
  "zh-CN": {
    "signIn": {
      "welcome": "欢迎使用 {name}",
      "email": "邮箱",
      "password": "密码",
      "emailPlaceholder": "邮箱地址",
      "passwordPlaceholder": "密码",
      "rememberMe": "记住我",
      "forgotPassword": "忘记密码？",
      "signIn": "登录",
      "noAccount": "还没有账号？",
      "createAccount": "立即注册！",
      "or": "或者",
      "signInSuccess": "登录成功",
      "errors": {
        "invalidEmail": "无效的邮箱地址",
        "passwordLength": "密码长度至少为{min}个字符"
      },
      "emailNotVerified": "邮箱未验证",
      "emailNotVerifiedDesc": "请验证您的邮箱地址以继续。",
      "resendEmail": "重新发送验证邮件",
      "resendEmailSuccess": "验证邮件已发送",
      "resendEmailError": "发送验证邮件失败",
      "sendEmail": "发送验证邮件",
      "sendEmailSuccess": "验证邮件已发送",
      "sendEmailError": "发送验证邮件失败"
    }
  },
  "ja": {
    "signIn": {
      "welcome": "{name}へようこそ",
      "email": "メールアドレス",
      "password": "パスワード",
      "emailPlaceholder": "メールアドレス",
      "passwordPlaceholder": "パスワード",
      "rememberMe": "ログイン状態を保持",
      "forgotPassword": "パスワードをお忘れですか？",
      "signIn": "ログイン",
      "noAccount": "アカウントをお持ちでない方",
      "createAccount": "新規登録！",
      "or": "または",
      "signInSuccess": "ログインに成功しました",
      "errors": {
        "invalidEmail": "無効なメールアドレス",
        "passwordLength": "パスワードは{min}文字以上である必要があります"
      },
      "emailNotVerified": "メールアドレス未確認",
      "emailNotVerifiedDesc": "続行するにはメールアドレスを確認してください。",
      "resendEmail": "確認メールを再送信",
      "resendEmailSuccess": "確認メールを送信しました",
      "resendEmailError": "確認メールの送信に失敗しました",
      "sendEmail": "認証メールを送信",
      "sendEmailSuccess": "認証メールを送信しました",
      "sendEmailError": "認証メールの送信に失敗しました"
    }
  },
  "fr": {
    "signIn": {
      "welcome": "Bienvenue sur {name}",
      "email": "E-mail",
      "password": "Mot de passe",
      "emailPlaceholder": "Adresse e-mail",
      "passwordPlaceholder": "Mot de passe",
      "rememberMe": "Se souvenir de moi",
      "forgotPassword": "Mot de passe oublié ?",
      "signIn": "Se connecter",
      "noAccount": "Vous n'avez pas de compte ?",
      "createAccount": "Créez-en un !",
      "or": "Ou",
      "signInSuccess": "Connexion réussie",
      "errors": {
        "invalidEmail": "Adresse e-mail invalide",
        "passwordLength": "Le mot de passe doit contenir au moins {min} caractères"
      },
      "emailNotVerified": "Email non vérifié",
      "emailNotVerifiedDesc": "Veuillez vérifier votre adresse e-mail pour continuer.",
      "resendEmail": "Renvoyer l'e-mail de vérification",
      "resendEmailSuccess": "L'e-mail de vérification a été envoyé",
      "resendEmailError": "Échec de l'envoi de l'e-mail de vérification",
      "sendEmail": "Envoyer l'e-mail de vérification",
      "sendEmailSuccess": "L'e-mail de vérification a été envoyé",
      "sendEmailError": "Échec de l'envoi de l'e-mail de vérification"
    }
  }
}



================================================
FILE: app/pages/signin/index.vue
================================================
<i18n src="./i18n.json"></i18n>

<script setup lang="ts">
definePageMeta({
  auth: {
    only: 'guest'
  }
})

const { t } = useI18n()

useHead({
  title: t('signIn.signIn')
})
const auth = useAuth()
const toast = useToast()
const route = useRoute()
const localePath = useLocalePath()

const redirectTo = computed(() => {
  const redirect = route.query.redirect as string
  return localePath(redirect || '/')
})

const schema = z.object({
  email: z.email(t('signIn.errors.invalidEmail')),
  password: z.string().min(8, t('signIn.errors.passwordLength', { min: 8 })),
  rememberMe: z.boolean().optional()
})
type Schema = zodOutput<typeof schema>

const state = reactive<Partial<Schema>>({
  email: undefined,
  password: undefined,
  rememberMe: false
})

const loading = ref(false)
const loadingAction = ref('')
const isEmailVerifyModalOpen = ref(false)
const resendLoading = ref(false)
let unverifiedEmail = ''

async function onSocialLogin(action: 'google' | 'github') {
  loading.value = true
  loadingAction.value = action
  auth.signIn.social({ provider: action, callbackURL: redirectTo.value })
}

async function onSubmit(event: FormSubmitEvent<Schema>) {
  if (loading.value)
    return
  loading.value = true
  loadingAction.value = 'submit'
  const { error } = await auth.signIn.email({
    email: event.data.email,
    password: event.data.password,
    rememberMe: event.data.rememberMe,
    callbackURL: redirectTo.value
  })
  if (error) {
    if (error.code === auth.errorCodes.EMAIL_NOT_VERIFIED) {
      unverifiedEmail = event.data.email
      isEmailVerifyModalOpen.value = true
      loading.value = false
      return
    }
    toast.add({
      title: error.message,
      color: 'error'
    })
  }
  loading.value = false
}

async function handleResendEmail() {
  if (resendLoading.value)
    return
  resendLoading.value = true
  const { error } = await auth.sendVerificationEmail({
    email: unverifiedEmail,
    callbackURL: redirectTo.value
  })
  if (error) {
    toast.add({
      title: error.message,
      color: 'error'
    })
  } else {
    toast.add({
      title: t('signIn.sendEmailSuccess'),
      color: 'success'
    })
  }

  isEmailVerifyModalOpen.value = false
  resendLoading.value = false
}
</script>

<template>
  <UContainer class="flex items-center justify-center sm:p-4 sm:min-w-160">
    <UCard class="w-full max-w-md">
      <template #header>
        <div class="text-center p-4">
          <h1 class="text-xl font-semibold">
            {{ t('signIn.welcome', { name: t('global.appName') }) }}
          </h1>
        </div>
      </template>
      <div class="space-y-4">
        <div class="grid grid-cols-1 sm:grid-cols-2 gap-2">
          <UButton
            color="neutral"
            variant="outline"
            icon="i-simple-icons-google"
            class="justify-center"
            :loading="loading && loadingAction === 'google'"
            :disabled="loading"
            @click="onSocialLogin('google')"
          >
            Google
          </UButton>
          <UButton
            color="neutral"
            variant="outline"
            icon="i-simple-icons-github"
            class="justify-center"
            :loading="loading && loadingAction === 'github'"
            :disabled="loading"
            @click="onSocialLogin('github')"
          >
            Github
          </UButton>
        </div>

        <USeparator :label="t('signIn.or')" />

        <UForm
          :schema="schema"
          :state="state"
          class="space-y-4"
          @submit="onSubmit"
        >
          <UFormField
            :label="t('signIn.email')"
            name="email"
            required
          >
            <UInput
              v-model="state.email"
              type="email"
              class="w-full"
              :placeholder="t('signIn.emailPlaceholder')"
              autocomplete="email"
            />
          </UFormField>

          <UFormField
            :label="t('signIn.password')"
            name="password"
            required
          >
            <UInput
              v-model="state.password"
              type="password"
              class="w-full"
              :placeholder="t('signIn.passwordPlaceholder')"
            />
          </UFormField>

          <div class="flex flex-col sm:flex-row items-start sm:items-center justify-between gap-2">
            <UFormField name="rememberMe">
              <UCheckbox
                v-model="state.rememberMe"
                :label="t('signIn.rememberMe')"
              />
            </UFormField>
            <UButton
              variant="link"
              color="neutral"
              :to="localePath('/forgot-password')"
            >
              {{ t('signIn.forgotPassword') }}
            </UButton>
          </div>

          <UButton
            type="submit"
            color="primary"
            block
            :disabled="loading"
            :loading="loading && loadingAction === 'submit'"
          >
            {{ t('signIn.signIn') }}
          </UButton>

          <div class="text-center text-sm">
            {{ t('signIn.noAccount') }}
            <UButton
              variant="link"
              color="primary"
              :disabled="loading"
              :to="localePath('/signup')"
            >
              {{ t('signIn.createAccount') }}
            </UButton>
          </div>
        </UForm>
      </div>
    </UCard>

    <UModal v-model:open="isEmailVerifyModalOpen">
      <template #content>
        <UCard>
          <template #header>
            <div class="flex items">
              <h3 class="text-lg font-medium">
                {{ t('signIn.emailNotVerified') }}
              </h3>
            </div>
          </template>

          <p class="text-sm">
            {{ t('signIn.emailNotVerifiedDesc') }}
          </p>

          <template #footer>
            <div class="flex justify-end gap-3">
              <UButton
                color="neutral"
                variant="outline"
                @click="isEmailVerifyModalOpen = false"
              >
                {{ t('global.page.cancel') }}
              </UButton>
              <UButton
                color="primary"
                :loading="resendLoading"
                @click="handleResendEmail"
              >
                {{ t('signIn.sendEmail') }}
              </UButton>
            </div>
          </template>
        </UCard>
      </template>
    </UModal>
  </UContainer>
</template>



================================================
FILE: app/pages/signup/i18n.json
================================================
{
  "en": {
    "signUp": {
      "pageTitle": "Sign up",
      "title": "Create your account",
      "or": "Or",
      "form": {
        "name": {
          "label": "Name",
          "placeholder": "Your Name",
          "error": "Name must be at least {min} characters"
        },
        "email": {
          "label": "Email",
          "placeholder": "Email Address",
          "error": "Invalid email address"
        },
        "password": {
          "label": "Password",
          "placeholder": "Password",
          "error": "Password must be at least {min} characters"
        },
        "confirmPassword": {
          "label": "Confirm Password",
          "placeholder": "Confirm Password",
          "error": "Passwords don't match"
        }
      },
      "submit": "Create Account",
      "haveAccount": "Already have an account?",
      "signIn": "Sign in here",
      "sendEmailSuccess": "Verification email has been sent, Please verify your email address to continue."
    }
  },
  "zh-CN": {
    "signUp": {
      "pageTitle": "注册账号",
      "title": "创建账号",
      "or": "或者",
      "form": {
        "name": {
          "label": "姓名",
          "placeholder": "请输入姓名",
          "error": "姓名至少需要{min}个字符"
        },
        "email": {
          "label": "邮箱",
          "placeholder": "请输入邮箱地址",
          "error": "无效的邮箱地址"
        },
        "password": {
          "label": "密码",
          "placeholder": "请输入密码",
          "error": "密码至少需要{min}个字符"
        },
        "confirmPassword": {
          "label": "确认密码",
          "placeholder": "请再次输入密码",
          "error": "两次输入的密码不一致"
        }
      },
      "submit": "创建账号",
      "haveAccount": "已有账号？",
      "signIn": "此处登录",
      "sendEmailSuccess": "验证邮件已发送，请验证您的邮箱地址以继续。"
    }
  },
  "ja": {
    "signUp": {
      "pageTitle": "新規登録",
      "title": "アカウント作成",
      "or": "または",
      "form": {
        "name": {
          "label": "名前",
          "placeholder": "名前を入力",
          "error": "名前は{min}文字以上である必要があります"
        },
        "email": {
          "label": "メールアドレス",
          "placeholder": "メールアドレスを入力",
          "error": "無効なメールアドレス"
        },
        "password": {
          "label": "パスワード",
          "placeholder": "パスワードを入力",
          "error": "パスワードは{min}文字以上である必要があります"
        },
        "confirmPassword": {
          "label": "パスワード（確認）",
          "placeholder": "パスワードを再入力",
          "error": "パスワードが一致しません"
        }
      },
      "submit": "アカウント作成",
      "haveAccount": "既にアカウントをお持ちですか？",
      "signIn": "ログインする",
      "sendEmailSuccess": "確認メールを送信しました。メールアドレスを確認して続行してください。"
    }
  },
  "fr": {
    "signUp": {
      "pageTitle": "S'inscrire",
      "title": "Créer votre compte",
      "or": "Ou",
      "form": {
        "name": {
          "label": "Nom",
          "placeholder": "Votre nom",
          "error": "Le nom doit contenir au moins {min} caractères"
        },
        "email": {
          "label": "Email",
          "placeholder": "Adresse email",
          "error": "Adresse email invalide"
        },
        "password": {
          "label": "Mot de passe",
          "placeholder": "Mot de passe",
          "error": "Le mot de passe doit contenir au moins {min} caractères"
        },
        "confirmPassword": {
          "label": "Confirmer le mot de passe",
          "placeholder": "Confirmer le mot de passe",
          "error": "Les mots de passe ne correspondent pas"
        }
      },
      "submit": "Créer un compte",
      "haveAccount": "Vous avez déjà un compte ?",
      "signIn": "Connectez-vous ici",
      "sendEmailSuccess": "L'email de vérification a été envoyé. Veuillez vérifier votre adresse email pour continuer."
    }
  }
}



================================================
FILE: app/pages/signup/index.vue
================================================
<i18n src="./i18n.json"></i18n>

<script setup lang="ts">
definePageMeta({
  auth: {
    only: 'guest'
  }
})

const { t } = useI18n()

useHead({
  title: t('signUp.pageTitle')
})

const auth = useAuth()
const toast = useToast()
const route = useRoute()
const localePath = useLocalePath()

const redirectTo = computed(() => {
  const redirect = route.query.redirect as string
  return localePath(redirect || '/')
})

const schema = z.object({
  name: z.string().min(5, t('signUp.form.name.error', { min: 5 })),
  email: z.email(t('signUp.form.email.error')),
  password: z.string().min(8, t('signUp.form.password.error', { min: 8 })),
  confirmPassword: z.string()
}).refine(data => data.password === data.confirmPassword, {
  message: t('signUp.form.confirmPassword.error'),
  path: ['confirmPassword']
})

type Schema = zodOutput<typeof schema>

const state = reactive<Partial<Schema>>({
  name: undefined,
  email: undefined,
  password: undefined,
  confirmPassword: undefined
})

const loading = ref(false)
const loadingAction = ref('')

async function onSocialLogin(action: 'google' | 'github') {
  loading.value = true
  loadingAction.value = action
  auth.signIn.social({ provider: action, callbackURL: redirectTo.value })
}

async function onSubmit(event: FormSubmitEvent<Schema>) {
  if (loading.value)
    return
  loading.value = true
  loadingAction.value = 'submit'
  const { error } = await auth.signUp.email({
    name: event.data.name,
    email: event.data.email,
    password: event.data.password
  })
  if (error) {
    toast.add({
      title: error.message || error.statusText,
      color: 'error'
    })
  }
  else {
    toast.add({
      title: t('signUp.sendEmailSuccess'),
      color: 'success'
    })
    state.name = undefined
    state.email = undefined
    state.password = undefined
    state.confirmPassword = undefined
  }
  loading.value = false
}
</script>

<template>
  <UContainer class="flex items-center justify-center sm:p-4 sm:min-w-160">
    <UCard class="w-full max-w-md">
      <template #header>
        <div class="text-center p-4">
          <h1 class="text-xl font-semibold">
            {{ t('signUp.title') }}
          </h1>
        </div>
      </template>

      <div class="space-y-4">
        <div class="grid grid-cols-1 sm:grid-cols-2 gap-2">
          <UButton
            color="neutral"
            variant="outline"
            icon="i-simple-icons-google"
            class="justify-center"
            :loading="loading && loadingAction === 'google'"
            :disabled="loading"
            @click="onSocialLogin('google')"
          >
            Google
          </UButton>
          <UButton
            color="neutral"
            variant="outline"
            icon="i-simple-icons-github"
            class="justify-center"
            :loading="loading && loadingAction === 'github'"
            :disabled="loading"
            @click="onSocialLogin('github')"
          >
            Github
          </UButton>
        </div>

        <USeparator :label="t('signUp.or')" />

        <UForm
          :schema="schema"
          :state="state"
          class="space-y-4"
          @submit="onSubmit"
        >
          <UFormField
            :label="t('signUp.form.name.label')"
            name="name"
            required
          >
            <UInput
              v-model="state.name"
              :placeholder="t('signUp.form.name.placeholder')"
              class="w-full"
            />
          </UFormField>

          <UFormField
            :label="t('signUp.form.email.label')"
            name="email"
            autocomplete="email"
            required
          >
            <UInput
              v-model="state.email"
              type="email"
              :placeholder="t('signUp.form.email.placeholder')"
              class="w-full"
            />
          </UFormField>

          <UFormField
            :label="t('signUp.form.password.label')"
            name="password"
            required
          >
            <UInput
              v-model="state.password"
              type="password"
              :placeholder="t('signUp.form.password.placeholder')"
              class="w-full"
            />
          </UFormField>

          <UFormField
            :label="t('signUp.form.confirmPassword.label')"
            name="confirmPassword"
            required
          >
            <UInput
              v-model="state.confirmPassword"
              type="password"
              :placeholder="t('signUp.form.confirmPassword.placeholder')"
              class="w-full"
            />
          </UFormField>

          <UButton
            type="submit"
            color="primary"
            block
            :loading="loading && loadingAction === 'submit'"
            :disabled="loading"
          >
            {{ t('signUp.submit') }}
          </UButton>
        </UForm>

        <div class="text-center text-sm">
          {{ t('signUp.haveAccount') }}
          <UButton
            variant="link"
            color="primary"
            :disabled="loading"
            :to="localePath('/signin')"
          >
            {{ t('signUp.signIn') }}
          </UButton>
        </div>
      </div>
    </UCard>
  </UContainer>
</template>



================================================
FILE: app/plugins/auth.client.ts
================================================
export default defineNuxtPlugin(async (nuxtApp) => {
  if (!nuxtApp.payload.serverRendered) {
    await useAuth().fetchSession()
  }
  else if (Boolean(nuxtApp.payload.prerenderedAt) || Boolean(nuxtApp.payload.isCached)) {
    // To avoid hydration mismatch
    nuxtApp.hook('app:mounted', async () => {
      await useAuth().fetchSession()
    })
  }
})



================================================
FILE: app/plugins/auth.server.ts
================================================
export default defineNuxtPlugin({
  name: 'better-auth-fetch-plugin',
  enforce: 'pre',
  async setup(nuxtApp) {
    // Flag if request is cached
    nuxtApp.payload.isCached = Boolean(useRequestEvent()?.context.cache)
    if (nuxtApp.payload.serverRendered && !nuxtApp.payload.prerenderedAt && !nuxtApp.payload.isCached) {
      await useAuth().fetchSession()
    }
  }
})



================================================
FILE: app/plugins/customFetch.ts
================================================
export default defineNuxtPlugin(() => {
  const $customFetch = $fetch.create({
    onRequest({ request, options }) {
      console.log(request, options)
    }
    // onResponse({ response }) {
    // },
    // onResponseError({ response }) {
    // }
  })
  // Expose to useNuxtApp().$customFetch
  return {
    provide: {
      customFetch: $customFetch
    }
  }
})



================================================
FILE: app/utils/columns.ts
================================================
export const htmlColumn = <T>(cell: ColumnCell<T>, el = 'span') => {
  const value = cell.getValue() as string
  return h(el, { innerHTML: value }, [])
}

export const IDColumn = <T>(cell: ColumnCell<T>) => {
  const value = cell.getValue() as string
  return h(UTooltip, {
    text: value,
    disableClosingTrigger: true
  }, () => h(
    'span',
    {},
    value.substring(0, 8)
  ))
}

export const showMoreColumn = <T>(cell: ColumnCell<T>, length: number) => {
  const value = cell.getValue() as string || ''
  if (value.length <= length) {
    return value
  }

  return h(UTooltip, {
    text: value,
    disableClosingTrigger: true
  }, () => h(
    'span',
    {},
    `${value.substring(0, length)}...`
  ))
}

export const dateColumn = <T>(cell: ColumnCell<T>) => {
  const value = cell.getValue() as Date | string
  return formatToDatetime(value)
}

export const yesNoColumn = <T>(cell: ColumnCell<T>, t: TranFunction) => {
  const value = cell.getValue() as boolean
  const color = value ? 'success' : 'error'
  return h(UBadge, { class: 'capitalize', variant: 'subtle', color }, () => value ? t('yes') : t('no'))
}

export const avatarColumn = <T>(cell: ColumnCell<T>) => {
  const value = cell.getValue() as string
  return h(UAvatar, { src: value })
}

export const isEnabledColumn = <T>(cell: ColumnCell<T>, t: TranFunction) => {
  const value = cell.getValue() as boolean
  const color = value ? 'success' : 'error'
  return h(UBadge, { class: 'capitalize', variant: 'subtle', color }, () => value ? t('enable') : t('disable'))
}

export const actionColumn = <T>(row: Row<T>, getRowItems: (row: Row<T>) => any[]) => {
  return h(
    'div',
    { class: 'text-right' },
    h(
      UDropdownMenu as any,
      {
        content: {
          align: 'end'
        },
        items: getRowItems(row)
      },
      () => h(UButton, {
        icon: 'i-lucide-ellipsis-vertical',
        color: 'neutral',
        variant: 'ghost',
        class: 'ml-auto'
      })
    )
  )
}



================================================
FILE: app/utils/components.ts
================================================
export { default as UAvatar } from '@nuxt/ui/runtime/components/Avatar.vue'
export { default as UBadge } from '@nuxt/ui/runtime/components/Badge.vue'
export { default as UButton } from '@nuxt/ui/runtime/components/Button.vue'
export { default as UDropdownMenu } from '@nuxt/ui/runtime/components/DropdownMenu.vue'
export { default as UTable } from '@nuxt/ui/runtime/components/Table.vue'
export { default as UTooltip } from '@nuxt/ui/runtime/components/Tooltip.vue'



================================================
FILE: app/utils/date.ts
================================================
import { CalendarDate, getLocalTimeZone } from '@internationalized/date'
import { endOfDay, format, parseISO, startOfDay } from 'date-fns'

export const DATE_FORMAT = 'yyyy-MM-dd'
export const DATETIME_FORMAT = 'yyyy-MM-dd HH:mm:ss'

export const getTimeZone = () => {
  const timezone = getLocalTimeZone()
  return timezone
}

export const formatDate = (date: Date | undefined) => {
  if (!date) {
    return ''
  }
  return new Date(date).toLocaleDateString('en-US', {
    year: 'numeric',
    month: 'long',
    day: 'numeric',
    hour: '2-digit',
    minute: '2-digit'
  })
}

export const toCalendarDate = (date: Date) => {
  return new CalendarDate(date.getFullYear(), date.getMonth() + 1, date.getDate())
}

export const toDate = (calendarDate: CalendarDate) => {
  const timezone = getLocalTimeZone()
  return calendarDate.toDate(timezone)
}

export const formatToDate = (value: CalendarDate | Date | string) => {
  let date
  if (value instanceof CalendarDate) {
    const timezone = getLocalTimeZone()
    date = value.toDate(timezone)
  } else if (value instanceof Date) {
    date = value
  } else {
    // 2024-12-27T06:11:35.707+00:00
    // 2024-12-27T06:11:35.707123+00:00
    date = parseISO(value)
  }
  return date
}

export const formatToDay = (value: CalendarDate | Date | string) => {
  const date = formatToDate(value)
  return format(date, DATE_FORMAT)
}

export const formatToDatetime = (value: CalendarDate | Date | string | undefined) => {
  if (!value) {
    return ''
  }
  const date = formatToDate(value)
  return format(date, DATETIME_FORMAT)
}

export const startOfDate = (date: CalendarDate | Date) => {
  if (date instanceof CalendarDate) {
    const timezone = getLocalTimeZone()
    return startOfDay(date.toDate(timezone))
  } else {
    return startOfDay(date)
  }
}

export const endOfDate = (date: CalendarDate | Date) => {
  if (date instanceof CalendarDate) {
    const timezone = getLocalTimeZone()
    return endOfDay(date.toDate(timezone))
  } else {
    return endOfDay(date)
  }
}



================================================
FILE: app/utils/types.ts
================================================
import type { CalendarDate } from '@internationalized/date'
import type { TableColumn } from '@nuxt/ui'
import type { CellContext, RowData } from '@tanstack/vue-table'

export type { FormSubmitEvent, NavigationMenuItem, TableData } from '@nuxt/ui'
export type { Row } from '@tanstack/vue-table'
export { z } from 'zod/v4'
export type { output as zodOutput } from 'zod/v4'
export { locales as zodLocales } from 'zod/v4'

export type TranFunction = (name: string, options?: StringDict<any>) => string
export type ColumnCell<TData extends RowData, TValue = unknown> = CellContext<TData, TValue>
export type AdminTableColumn<T extends TableData, D = unknown> = TableColumn<T, D> & {
  accessorKey?: string
  header?: string
  id?: string
}

export interface StringDict<T> {
  [key: string]: T
}

export interface FilterItem {
  label: string
  id: string
  count?: number
}

export interface FilterInput {
  name: string
  field: string
  value: string | undefined
  type: 'input'
}

export interface FilterCheckbox {
  name: string
  field: string
  value: string[]
  type: 'checkbox'
  items: FilterItem[]
}

export interface FilterTabs {
  name: string
  field: string
  value: string
  type: 'tabs'
  items: FilterItem[]
}

export interface FilterDateRange {
  name: string
  field: string
  value: DateRange
  type: 'daterange'
}

export interface DateRange { start: CalendarDate | undefined, end: CalendarDate | undefined }

export type AdminTableFilter =
  | FilterInput
  | FilterCheckbox
  | FilterTabs
  | FilterDateRange

export interface SortOption {
  field: string
  order: 'asc' | 'desc'
}

export type FilterCondition = {
  col: string
  op: 'between'
  v: [string, string]
} | {
  col: string
  op: 'in'
  v: string[]
} | {
  col: string
  op: 'like'
  v: string
} | {
  col: string
  op: 'eq'
  v: string
}

export interface FetchDataParams {
  page: number
  limit: number
  sort: SortOption[]
  filter: FilterCondition[]
}

export interface PageData<T> {
  data: T[]
  total: number
}

export type FetchDataFn<T> = (params: FetchDataParams) => Promise<PageData<T>>

export interface ColumnCount {
  column: string
  count: number
}



================================================
FILE: public/favicons/site.webmanifest
================================================
{
  "name": "NuxSaaS",
  "short_name": "NuxSaaS",
  "icons": [
    {
      "src": "/favicons/web-app-manifest-192x192.png",
      "sizes": "192x192",
      "type": "image/png",
      "purpose": "maskable"
    },
    {
      "src": "/favicons/web-app-manifest-512x512.png",
      "sizes": "512x512",
      "type": "image/png",
      "purpose": "maskable"
    }
  ],
  "theme_color": "#ffffff",
  "background_color": "#ffffff",
  "display": "standalone"
}


================================================
FILE: public/screenshots/dashboard.webp
================================================
[Binary file]


================================================
FILE: public/screenshots/home.webp
================================================
[Binary file]


================================================
FILE: public/screenshots/pricing.webp
================================================
[Binary file]


================================================
FILE: public/screenshots/signin.webp
================================================
[Binary file]


================================================
FILE: public/screenshots/subscription.webp
================================================
[Binary file]


================================================
FILE: public/screenshots/users.webp
================================================
[Binary file]


================================================
FILE: server/tsconfig.json
================================================
{
  "extends": "../.nuxt/tsconfig.server.json"
}



================================================
FILE: server/api/admin/count/[tableName]/[columnName].get.ts
================================================
import type { PgColumn } from 'drizzle-orm/pg-core'
import { getTableColumns, sql } from 'drizzle-orm'
import { PgTable } from 'drizzle-orm/pg-core'
import { z } from 'zod'
import * as schema from '~~/server/database/schema'
import { isValidTable } from '~~/server/utils/db'
import { filterSchema, processFilters, withFilters } from '~~/server/utils/query'

const pathSchema = z.object({
  tableName: z.string().min(1),
  columnName: z.string().min(1)
})

const querySchema = z.object({
  filter: z.string()
    .transform((str) => {
      try {
        const parsed = JSON.parse(str)
        if (!Array.isArray(parsed))
          return []

        return parsed.reduce<z.infer<typeof filterSchema>>((validFilters, item) => {
          const result = filterSchema.element.safeParse(item)
          if (result.success) {
            validFilters.push(result.data)
          }
          return validFilters
        }, [])
      }
      catch {
        return []
      }
    })
    .optional()
})

export default eventHandler(async (event) => {
  const params = await getValidatedRouterParams(event, pathSchema.parse)
  const query = await getValidatedQuery(event, querySchema.parse)

  const { tableName, columnName } = params
  if (!isValidTable(tableName)) {
    throw createError({
      statusCode: 400,
      statusMessage: 'Bad Request',
      data: 'INVALID_TABLE_NAME',
      message: 'Invalid Table Name'
    })
  }

  const table = schema[tableName]
  if (!(table instanceof PgTable)) {
    throw createError(
      {
        statusCode: 400,
        statusMessage: 'Bad Request',
        data: 'INVALID_TABLE_TYPE',
        message: 'Invalid Table Name'
      }
    )
  }
  const columns = getTableColumns(table)

  if (!(columnName in columns)) {
    throw createError({
      statusCode: 400,
      statusMessage: 'Bad Request',
      data: 'INVALID_COLUMN_NAME',
      message: 'Invalid Column Name'
    })
  }

  const db = await useDB(event)

  const columnKey = columnName as keyof typeof columns
  const column = table[columnKey] as PgColumn
  const countQuery = db.select({ column, count: sql<number>`cast(count(*) as int)` })
    .from(table)
    .groupBy(column)
    .$dynamic()

  if (query?.filter) {
    const filters = processFilters(query.filter, columns)
    if (filters.length) {
      withFilters(countQuery, filters)
    }
  }

  const result = await countQuery
  return result
})



================================================
FILE: server/api/admin/list/[tableName].get.ts
================================================
import type { SQL } from 'drizzle-orm'
import type { PgSelect } from 'drizzle-orm/pg-core'
import { asc, desc, getTableColumns, sql } from 'drizzle-orm'
import { PgTable } from 'drizzle-orm/pg-core'
import { z } from 'zod'
import * as schema from '~~/server/database/schema'
import { isValidTable } from '~~/server/utils/db'
import { filterSchema, processFilters, withFilters } from '~~/server/utils/query'

function withSorts<T extends PgSelect>(
  qb: T,
  sorts: SQL[]
) {
  return qb.orderBy(...sorts)
}

function withPagination<T extends PgSelect>(
  qb: T,
  page: number = 1,
  pageSize: number = 10
) {
  return qb.limit(pageSize).offset((page - 1) * pageSize)
}

const sortSchema = z.array(
  z.tuple([
    z.string(),
    z.enum(['asc', 'desc'])
  ])
)

const querySchema = z.object({
  page: z.coerce.number().int().positive().default(1),
  limit: z.coerce.number().int().positive().max(100).default(20),
  filter: z.string()
    .transform((str) => {
      try {
        const parsed = JSON.parse(str)
        if (!Array.isArray(parsed))
          return []

        return parsed.reduce<z.infer<typeof filterSchema>>((validFilters, item) => {
          const result = filterSchema.element.safeParse(item)
          if (result.success) {
            validFilters.push(result.data)
          }
          return validFilters
        }, [])
      }
      catch {
        return []
      }
    })
    .optional(),
  sort: z.string()
    .transform((str) => {
      try {
        const parsed = JSON.parse(str)
        if (!Array.isArray(parsed))
          return []

        return parsed.reduce<z.infer<typeof sortSchema>>((validSorts, item) => {
          const result = sortSchema.element.safeParse(item)
          if (result.success) {
            validSorts.push(result.data)
          }
          return validSorts
        }, [])
      }
      catch {
        return []
      }
    })
    .optional()
})

export default eventHandler(async (event) => {
  const tableName = getRouterParam(event, 'tableName')
  if (!tableName) {
    throw createError({
      statusCode: 400,
      statusMessage: 'Bad Request',
      data: 'EMPTY_TABLE_NAME',
      message: 'Empty Table Name'
    })
  }

  if (!isValidTable(tableName)) {
    throw createError({
      statusCode: 400,
      statusMessage: 'Bad Request',
      data: 'INVALID_TABLE_NAME',
      message: 'Invalid Table Name'
    })
  }

  const table = schema[tableName]
  if (!(table instanceof PgTable)) {
    throw createError(
      {
        statusCode: 400,
        statusMessage: 'Bad Request',
        data: 'INVALID_TABLE_TYPE',
        message: 'Invalid Table Name'
      }
    )
  }
  const columns = getTableColumns(table)

  const query = await getValidatedQuery(event, querySchema.parse)
  const db = await useDB(event)

  const listQuery = db.select().from(table).$dynamic()
  const totalQuery = db.select({ count: sql<number>`cast(count(*) as int)` }).from(table).$dynamic()

  if (query) {
    // Handle filters
    if (query.filter) {
      const filters = processFilters(query.filter, columns)
      if (filters.length) {
        withFilters(listQuery, filters)
        withFilters(totalQuery, filters)
      }
    }
    // Handle sorting
    if (query.sort?.length) {
      const sorts: SQL[] = []
      for (const [field, direction] of query.sort) {
        if (field in columns) {
          const columnKey = field as keyof typeof columns
          const orderFunc = direction === 'desc' ? desc : asc
          sorts.push(orderFunc(columns[columnKey]))
        }
      }
      withSorts(listQuery, sorts)
    } else if ('id' in columns) {
      // Fallback sort to id desc
      const sorts: SQL[] = [desc(columns.id)]
      withSorts(listQuery, sorts)
    }
  }

  // Handle pagination
  const page = query?.page || 1
  const limit = query?.limit || 20
  withPagination(listQuery, page, limit)
  const count = await totalQuery
  const result = await listQuery

  return {
    data: result,
    total: count[0]?.count || 0,
    page,
    limit
  }
})



================================================
FILE: server/api/admin/maintenance/db-stats.ts
================================================
import { getDBStats } from '~~/server/utils/dbStats'

export default defineEventHandler(async () => {
  return getDBStats()
})



================================================
FILE: server/api/admin/maintenance/ensure-payment-customers.ts
================================================
import { eq } from 'drizzle-orm'
import { user as userTable } from '~~/server/database/schema'
import { useDB } from '~~/server/utils/db'
import { ensurePolarCustomer } from '~~/server/utils/polar'
import { runtimeConfig } from '~~/server/utils/runtimeConfig'
import { ensureStripeCustomer } from '~~/server/utils/stripe'

export default defineEventHandler(async (event) => {
  const db = await useDB(event)

  // Get all users from database
  const users = await db.select().from(userTable)

  const results = {
    totalUsers: users.length,
    stripeResults: [] as Array<{ userId: string, status: 'success' | 'error', message?: string }>,
    polarResults: [] as Array<{ userId: string, status: 'success' | 'error', message?: string }>
  }

  // Process each user
  for (const user of users) {
    // Ensure Stripe customer if Stripe is enabled
    if (runtimeConfig.public.payment === 'stripe' && runtimeConfig.stripeSecretKey) {
      if (user.stripeCustomerId) {
        results.stripeResults.push({
          userId: user.id,
          status: 'success'
        })
        continue
      }
      try {
        const customer = await ensureStripeCustomer(user)
        if (customer) {
          await db.update(userTable).set({
            stripeCustomerId: customer.id
          }).where(eq(userTable.id, user.id))
        }
        results.stripeResults.push({
          userId: user.id,
          status: 'success'
        })
      } catch (error) {
        results.stripeResults.push({
          userId: user.id,
          status: 'error',
          message: error instanceof Error ? error.message : 'Unknown error'
        })
      }
    }

    // Ensure Polar customer if Polar is enabled
    if (runtimeConfig.public.payment === 'polar' && runtimeConfig.polarAccessToken) {
      if (user.polarCustomerId) {
        results.polarResults.push({
          userId: user.id,
          status: 'success'
        })
        continue
      }
      try {
        const customer = await ensurePolarCustomer(user)
        if (customer && customer.externalId) {
          await db.update(userTable).set({
            polarCustomerId: customer.id
          }).where(eq(userTable.id, user.id))
        }
        results.polarResults.push({
          userId: user.id,
          status: 'success'
        })
      } catch (error) {
        results.polarResults.push({
          userId: user.id,
          status: 'error',
          message: error instanceof Error ? error.message : 'Unknown error'
        })
      }
    }
  }

  return {
    success: true,
    data: results,
    summary: {
      totalUsers: results.totalUsers,
      stripeSuccessCount: results.stripeResults.filter(r => r.status === 'success').length,
      stripeErrorCount: results.stripeResults.filter(r => r.status === 'error').length,
      polarSuccessCount: results.polarResults.filter(r => r.status === 'success').length,
      polarErrorCount: results.polarResults.filter(r => r.status === 'error').length
    }
  }
})



================================================
FILE: server/api/auth/[...all].ts
================================================
import { useServerAuth } from '~~/server/utils/auth'

export default defineEventHandler((event) => {
  const serverAuth = useServerAuth()
  return serverAuth.handler(toWebRequest(event))
})



================================================
FILE: server/database/drizzle.config.ts
================================================
import { defineConfig } from 'drizzle-kit'

export default defineConfig({
  dialect: 'postgresql',
  schema: './server/database/schema/index.ts',
  out: './server/database/migrations',
  dbCredentials: {
    url: process.env.NUXT_DATABASE_URL!
  }
})



================================================
FILE: server/database/schema/auditLog.ts
================================================
import { pgTable, serial, text, timestamp, uuid } from 'drizzle-orm/pg-core'
import { user } from './auth'

export const auditLog = pgTable('audit_log', {
  id: serial('id').primaryKey(),
  userId: uuid('user_id').references(() => user.id, { onDelete: 'set null' }),
  category: text('category').notNull(), // e.g., 'auth', 'email', 'payment'
  action: text('action').notNull(), // e.g., 'login', 'register', 'verification'
  targetType: text('target_type'), // e.g., 'user', 'email'
  targetId: text('target_id'), // ID of the target entity
  ipAddress: text('ip_address'),
  userAgent: text('user_agent'),
  status: text('status').notNull().default('success'), // e.g., 'success', 'failure', 'pending'
  details: text('details'), // Additional details or error messages
  createdAt: timestamp('created_at').notNull().$default(() => new Date())
})



================================================
FILE: server/database/schema/auth.ts
================================================
// generated using npm run auth:schema, and change text('id') to uuid('id')

import {
  boolean,
  integer,
  pgTable,
  text,
  timestamp,
  uuid
} from 'drizzle-orm/pg-core'

export const user = pgTable('user', {
  id: uuid('id').primaryKey(),
  name: text('name').notNull(),
  email: text('email').notNull().unique(),
  emailVerified: boolean('email_verified')
    .$defaultFn(() => false)
    .notNull(),
  image: text('image'),
  createdAt: timestamp('created_at')
    .$defaultFn(() => /* @__PURE__ */ new Date())
    .notNull(),
  updatedAt: timestamp('updated_at')
    .$defaultFn(() => /* @__PURE__ */ new Date())
    .notNull(),
  role: text('role'),
  banned: boolean('banned'),
  banReason: text('ban_reason'),
  banExpires: timestamp('ban_expires'),
  stripeCustomerId: text('stripe_customer_id'),
  polarCustomerId: text('polar_customer_id')
})

export const account = pgTable('account', {
  id: uuid('id').primaryKey(),
  accountId: text('account_id').notNull(),
  providerId: text('provider_id').notNull(),
  userId: uuid('user_id')
    .notNull()
    .references(() => user.id, { onDelete: 'cascade' }),
  accessToken: text('access_token'),
  refreshToken: text('refresh_token'),
  idToken: text('id_token'),
  accessTokenExpiresAt: timestamp('access_token_expires_at'),
  refreshTokenExpiresAt: timestamp('refresh_token_expires_at'),
  scope: text('scope'),
  password: text('password'),
  createdAt: timestamp('created_at').notNull(),
  updatedAt: timestamp('updated_at').notNull()
})

export const verification = pgTable('verification', {
  id: uuid('id').primaryKey(),
  identifier: text('identifier').notNull(),
  value: text('value').notNull(),
  expiresAt: timestamp('expires_at').notNull(),
  createdAt: timestamp('created_at').$defaultFn(
    () => /* @__PURE__ */ new Date()
  ),
  updatedAt: timestamp('updated_at').$defaultFn(
    () => /* @__PURE__ */ new Date()
  )
})

export const subscription = pgTable('subscription', {
  id: uuid('id').primaryKey(),
  plan: text('plan').notNull(),
  referenceId: text('reference_id').notNull(),
  stripeCustomerId: text('stripe_customer_id'),
  stripeSubscriptionId: text('stripe_subscription_id'),
  status: text('status').default('incomplete'),
  periodStart: timestamp('period_start'),
  periodEnd: timestamp('period_end'),
  cancelAtPeriodEnd: boolean('cancel_at_period_end'),
  seats: integer('seats')
})



================================================
FILE: server/database/schema/index.ts
================================================
export * from './auditLog'
export * from './auth'



================================================
FILE: server/middleware/0.common.ts
================================================
export default defineEventHandler(async (event) => {
  const start = performance.now()

  const { req, res } = event.node
  await res.on('finish', () => {
    const duration = Math.round(performance.now() - start)
    const statusCode = res.statusCode
    const method = req.method
    const url = req.url

    const timestamp = new Date().toLocaleString('en-US', {
      year: 'numeric',
      month: '2-digit',
      day: '2-digit',
      hour: '2-digit',
      minute: '2-digit',
      second: '2-digit',
      hour12: false
    })
    // Access Log
    console.log(`[${timestamp}] ${method} ${url} ${statusCode} - ${duration}ms`)
  })
})



================================================
FILE: server/middleware/1.auth.ts
================================================
import { requireAuth } from '~~/server/utils/auth'

export default defineEventHandler(async (event) => {
  const path = event.path

  if (path?.startsWith('/api/admin')) {
    const session = await requireAuth(event)
    if (!session.user || (session.user as User).role !== 'admin') {
      throw createError({
        statusCode: 403,
        statusMessage: 'Forbidden',
        message: 'Admin access required.'
      })
    }
  }
})



================================================
FILE: server/types/hub.d.ts
================================================
import type { HubKV } from '@nuxthub/core'

declare global {
  const hubKV: () => HubKV
}

export {}



================================================
FILE: server/utils/auditLogger.ts
================================================
import { auditLog } from '../database/schema/auditLog'
import { getDB } from './db'

export async function logAuditEvent(data: {
  userId?: string
  category: 'auth' | 'email' | 'payment'
  action: string
  targetType?: string
  targetId?: string
  ipAddress?: string
  userAgent?: string
  status?: 'success' | 'failure' | 'pending'
  details?: string
}) {
  try {
    const db = getDB()
    await db.insert(auditLog).values({
      userId: data.userId,
      category: data.category,
      action: data.action,
      targetType: data.targetType,
      targetId: data.targetId,
      ipAddress: data.ipAddress,
      userAgent: data.userAgent,
      status: data.status || 'success',
      details: data.details
    })
  } catch (error) {
    console.error('Failed to log audit event:', error)
  }
}



================================================
FILE: server/utils/auth.ts
================================================
import type { H3Event } from 'h3'
import { betterAuth } from 'better-auth'
import { drizzleAdapter } from 'better-auth/adapters/drizzle'
import { APIError, createAuthMiddleware } from 'better-auth/api'
import { admin, openAPI } from 'better-auth/plugins'
import { v7 as uuidv7 } from 'uuid'
import * as schema from '../database/schema'
import { logAuditEvent } from './auditLogger'
import { getDB } from './db'
import { cacheClient, resendInstance } from './drivers'
import { setupPolar } from './polar'
import { runtimeConfig } from './runtimeConfig'
import { setupStripe } from './stripe'

console.log(`Base URL is ${runtimeConfig.public.baseURL}`)

const createBetterAuth = () => betterAuth({
  baseURL: runtimeConfig.public.baseURL,
  secret: runtimeConfig.betterAuthSecret,
  database: drizzleAdapter(
    getDB(),
    {
      provider: 'pg',
      schema
    }
  ),
  advanced: {
    database: {
      generateId: () => {
        return uuidv7()
      }
    }
  },
  user: {
    additionalFields: {
      polarCustomerId: {
        type: 'string',
        required: false,
        defaultValue: null
      }
    }
  },
  secondaryStorage: cacheClient,
  emailAndPassword: {
    enabled: true,
    requireEmailVerification: true,
    sendResetPassword: async ({ user, url }) => {
      const response = await resendInstance.emails.send({
        from: `${runtimeConfig.public.appName} <${runtimeConfig.public.appNotifyEmail}>`,
        to: user.email,
        subject: 'Reset your password',
        text: `Click the link to reset your password: ${url}`
      })
      await logAuditEvent({
        userId: user.id,
        category: 'email',
        action: 'reset_password',
        targetType: 'email',
        targetId: user.email,
        status: response.error ? 'failure' : 'success',
        details: response.error?.message
      })
      if (response.error) {
        console.error(`Failed to send reset password email: ${response.error.message}`)
        throw createError({
          statusCode: 500,
          statusMessage: 'Internal Server Error'
        })
      }
    }
  },
  emailVerification: {
    sendOnSignUp: true,
    autoSignInAfterVerification: true,
    sendVerificationEmail: async ({ user, url }) => {
      const response = await resendInstance.emails.send({
        from: `${runtimeConfig.public.appName} <${runtimeConfig.public.appNotifyEmail}>`,
        to: user.email,
        subject: 'Verify your email address',
        text: `Click the link to verify your email: ${url}`
      })
      await logAuditEvent({
        userId: user.id,
        category: 'email',
        action: 'verification',
        targetType: 'email',
        targetId: user.email,
        status: response.error ? 'failure' : 'success',
        details: response.error?.message
      })
      if (response.error) {
        console.error(`Failed to send verification email: ${response.error.message}`)
        throw createError({
          statusCode: 500,
          statusMessage: 'Internal Server Error'
        })
      }
    }
  },
  socialProviders: {
    github: {
      clientId: runtimeConfig.githubClientId!,
      clientSecret: runtimeConfig.githubClientSecret!
    },
    google: {
      clientId: runtimeConfig.googleClientId!,
      clientSecret: runtimeConfig.googleClientSecret!
    }
  },
  account: {
    accountLinking: {
      enabled: true
    }
  },
  hooks: {
    after: createAuthMiddleware(async (ctx) => {
      const ipAddress = ctx.getHeader('x-forwarded-for')
        || ctx.getHeader('remoteAddress') || undefined
      const userAgent = ctx.getHeader('user-agent') || undefined

      let targetType
      let targetId
      if (ctx.context.session) {
        targetType = 'user'
        targetId = ctx.context.session.user.id
      } else if (['/sign-in/email', '/sign-up/email', 'forget-password'].includes(ctx.path)) {
        targetType = 'email'
        targetId = ctx.body.email || ''
      }

      if (ctx.context.returned && ctx.context.returned instanceof APIError) {
        await logAuditEvent({
          userId: ctx.context.session?.user.id,
          category: 'auth',
          action: ctx.path,
          targetType,
          targetId,
          ipAddress,
          userAgent,
          status: 'failure',
          details: ctx.context.returned.body?.message
        })
      } else {
        if (['/sign-in/email', '/sign-up/email', '/forget-password', '/reset-password'].includes(ctx.path)) {
          let userId: string | undefined
          if (['/sign-in/email', '/sign-up/email'].includes(ctx.path)) {
            userId = ctx.context.newSession?.user.id
          } else {
            userId = ctx.context.session?.user.id
          }
          await logAuditEvent({
            userId,
            category: 'auth',
            action: ctx.path,
            targetType,
            targetId,
            ipAddress,
            userAgent,
            status: 'success'
          })
        }
      }
    })
  },
  plugins: [
    ...(runtimeConfig.public.appEnv === 'development' ? [openAPI()] : []),
    admin(),
    setupStripe(),
    setupPolar()
  ]
})

let _auth: ReturnType<typeof betterAuth>

// Used by npm run auth:schema only.
const isAuthSchemaCommand = process.argv.some(arg => arg.includes('server/database/schema/auth.ts'))
if (isAuthSchemaCommand) {
  _auth = createBetterAuth()
}
export const auth = _auth!

export const useServerAuth = () => {
  if (runtimeConfig.preset == 'node-server') {
    if (!_auth) {
      _auth = createBetterAuth()
    }
    return _auth
  } else {
    return createBetterAuth()
  }
}

export const getAuthSession = async (event: H3Event) => {
  const headers = event.headers
  const serverAuth = useServerAuth()
  const session = await serverAuth.api.getSession({
    headers
  })
  return session
}

export const requireAuth = async (event: H3Event) => {
  const session = await getAuthSession(event)
  if (!session) {
    throw createError({
      statusCode: 401,
      statusMessage: 'Unauthorized'
    })
  }
  // Save the session to the event context for later use
  event.context.auth = session!
  return session!
}



================================================
FILE: server/utils/db.ts
================================================
import type { NodePgDatabase } from 'drizzle-orm/node-postgres'
import type { EventHandlerRequest, H3Event } from 'h3'
import { drizzle } from 'drizzle-orm/node-postgres'

import * as schema from '../database/schema'
import { getPgPool } from './drivers'
import { runtimeConfig } from './runtimeConfig'

const createDB = (dbSchema?: typeof schema) => {
  return drizzle({ client: getPgPool(), schema: dbSchema })
}

let db: ReturnType<typeof createDB>

export const getDB = () => {
  if (runtimeConfig.preset == 'node-server') {
    if (!db) {
      db = createDB()
    }
    return db
  } else {
    return createDB()
  }
}

// use db with schema
export const useDB = async (event?: H3Event<EventHandlerRequest>): Promise<NodePgDatabase<typeof schema>> => {
  // If the event has a context with a db property, return it
  if (event && event.context.db) {
    return event.context.db
  }
  // Otherwise, create a new connection to the database
  const dbInstance = createDB(schema)
  if (event) {
    event.context.db = dbInstance
  }
  return dbInstance
}

export type TableNames = keyof typeof schema

export function isValidTable(table: string): table is TableNames {
  return table in schema
}



================================================
FILE: server/utils/dbStats.ts
================================================
import { getPgPool } from './drivers'

export async function getDBStats() {
  const db = await getPgPool().connect()
  const dbStatsResult = await db.query(`
    SELECT
      numbackends as active_backends,
      xact_commit as commits,
      xact_rollback as rollbacks,
      blks_read,
      blks_hit,
      tup_returned,
      tup_fetched,
      tup_inserted,
      tup_updated,
      tup_deleted,
      conflicts,
      temp_files,
      temp_bytes,
      deadlocks
    FROM pg_stat_database
    WHERE datname = current_database()
  `)
  db.release()
  const dbStats = dbStatsResult.rows[0]
  const cacheHitRatio = dbStats.blks_hit / (dbStats.blks_read + dbStats.blks_hit) * 100

  return {
    activeBackends: Number(dbStats.active_backends),
    transactions: {
      commits: Number(dbStats.commits),
      rollbacks: Number(dbStats.rollbacks)
    },
    tuples: {
      returned: Number(dbStats.tup_returned),
      fetched: Number(dbStats.tup_fetched),
      inserted: Number(dbStats.tup_inserted),
      updated: Number(dbStats.tup_updated),
      deleted: Number(dbStats.tup_deleted)
    },
    cacheHitRatio: Math.round(cacheHitRatio * 100) / 100,
    conflicts: Number(dbStats.conflicts),
    deadlocks: Number(dbStats.deadlocks),
    tempFiles: {
      count: Number(dbStats.temp_files),
      bytes: Number(dbStats.temp_bytes)
    }
  }
}



================================================
FILE: server/utils/drivers.ts
================================================
import type { Hyperdrive } from '@cloudflare/workers-types'
import Redis from 'ioredis'
import pg from 'pg'
import { Resend } from 'resend'
import { runtimeConfig } from './runtimeConfig'

const getDatabaseUrl = () => {
// @ts-expect-error globalThis.__env__ is not defined
  const hyperdrive = (process.env.HYPERDRIVE || globalThis.__env__?.HYPERDRIVE || globalThis.HYPERDRIVE) as Hyperdrive | undefined
  if (runtimeConfig.preset == 'node-server') {
    return runtimeConfig.databaseUrl
  } else {
    return hyperdrive?.connectionString || runtimeConfig.databaseUrl
  }
}

const createPgPool = () => new pg.Pool({
  connectionString: getDatabaseUrl(),
  max: 90,
  idleTimeoutMillis: 30000
})

let pgPool: pg.Pool

// PG Pool
export const getPgPool = () => {
  if (runtimeConfig.preset == 'node-server') {
    if (!pgPool) {
      pgPool = createPgPool()
    }
    return pgPool
  } else {
    return createPgPool()
  }
}

// Cache Client
let redisClient: Redis | undefined

const getRedisClient = () => {
  if (redisClient) {
    return redisClient
  } else {
    if (runtimeConfig.preset == 'node-server') {
      redisClient = new Redis(runtimeConfig.redisUrl)
      return redisClient
    }
  }
}

export const cacheClient = {
  get: async (key: string) => {
    const client = getRedisClient()
    if (client) {
      const value = await client.get(key)
      return value
    } else {
      const value = await hubKV().get(key)
      if (!value) {
        return null
      }
      return JSON.stringify(value)
    }
  },
  set: async (key: string, value: string, ttl: number | undefined) => {
    const client = getRedisClient()
    const stringValue = typeof value === 'string' ? value : JSON.stringify(value)
    if (client) {
      if (ttl) {
        await client.set(key, stringValue, 'EX', ttl)
      } else {
        await client.set(key, stringValue)
      }
    } else {
      if (ttl) {
        await hubKV().set(key, stringValue, { ttl })
      } else {
        await hubKV().set(key, stringValue)
      }
    }
  },
  delete: async (key: string) => {
    const client = getRedisClient()
    if (client) {
      await client.del(key)
    } else {
      await hubKV().del(key)
    }
  }
}

export const resendInstance = new Resend(runtimeConfig.resendApiKey)



================================================
FILE: server/utils/polar.ts
================================================
import type { Benefit } from '@polar-sh/sdk/models/components/benefit.js'
import type { BenefitGrantWebhook } from '@polar-sh/sdk/models/components/benefitgrantwebhook.js'
import type { Checkout } from '@polar-sh/sdk/models/components/checkout.js'
import type { Customer } from '@polar-sh/sdk/models/components/customer.js'
import type { CustomerState } from '@polar-sh/sdk/models/components/customerstate.js'
import type { Order } from '@polar-sh/sdk/models/components/order.js'
import type { Organization } from '@polar-sh/sdk/models/components/organization.js'
import type { Product } from '@polar-sh/sdk/models/components/product.js'
import type { Refund } from '@polar-sh/sdk/models/components/refund.js'
import type { Subscription } from '@polar-sh/sdk/models/components/subscription.js'
import { checkout, polar, portal, usage, webhooks } from '@polar-sh/better-auth'
import { Polar } from '@polar-sh/sdk'
import { eq } from 'drizzle-orm'
import { user as userTable } from '../database/schema'
import { runtimeConfig } from './runtimeConfig'

const createPolarClient = () => {
  return new Polar({
    accessToken: runtimeConfig.polarAccessToken,
    server: runtimeConfig.polarServer as 'sandbox' | 'production'
  })
}

export const ensurePolarCustomer = async (user: User) => {
  const client = createPolarClient()
  const { result: existingCustomers } = await client.customers.list({ email: user.email })
  const existingCustomer = existingCustomers.items[0]
  if (existingCustomer) {
    if (existingCustomer.externalId !== user.id) {
      await client.customers.update({
        id: existingCustomer.id,
        customerUpdate: {
          externalId: user.id
        }
      })
    }
    return existingCustomer
  } else {
    const customer = await client.customers.create({
      email: user.email,
      name: user.name,
      externalId: user.id
    })
    return customer
  }
}

const addPaymentLog = async (hookType: string, data: Customer | Checkout | Benefit | BenefitGrantWebhook | Order | Organization | Product | Refund | Subscription | CustomerState) => {
  if (hookType.startsWith('checkout.')) {
    const checkout = data as Checkout
    await logAuditEvent({
      userId: checkout.customerExternalId || undefined,
      category: 'payment',
      action: `polar:${hookType}:${checkout.product.name}`,
      targetType: 'polarExternalId',
      targetId: checkout.customerExternalId || checkout.metadata.email as string,
      status: 'success'
    })
  } else if (hookType.startsWith('customer.')) {
    const customer = data as Customer
    if (hookType == 'customer.created' && customer.externalId) {
      const db = await useDB()
      await db.update(userTable).set({
        polarCustomerId: customer.id
      }).where(eq(userTable.id, customer.externalId))
    }
    await logAuditEvent({
      userId: customer.externalId || undefined,
      category: 'payment',
      action: `polar:${hookType}`,
      targetType: 'polarExternalId',
      targetId: customer.externalId || undefined,
      status: 'success'
    })
  } else if (hookType.startsWith('subscription.')) {
    const subscription = data as Subscription
    await logAuditEvent({
      userId: subscription.customer.externalId || undefined,
      category: 'payment',
      action: `polar:${hookType}:${subscription.product.name}`,
      targetType: 'polarExternalId',
      targetId: subscription.customer.externalId || undefined,
      status: 'success'
    })
  }
}

export const setupPolar = () => polar({
  client: createPolarClient(),
  createCustomerOnSignUp: runtimeConfig.public.payment == 'polar',
  use: [
    checkout({
      products: [
        {
          productId: runtimeConfig.polarProductIdProMonth,
          slug: 'pro-monthly'
        },
        {
          productId: runtimeConfig.polarProductIdProYear,
          slug: 'pro-yearly'
        }
      ],
      successUrl: '/',
      authenticatedUsersOnly: true
    }),
    portal(),
    usage(),
    webhooks({
      // On Polar Organization Settings: {APP_URL}/api/auth/polar/webhooks
      secret: runtimeConfig.polarWebhookSecret,
      onPayload: async (payload) => {
        // Catch-all for all events
        await addPaymentLog(payload.type || '', payload.data)
      }
    })
  ]
})



================================================
FILE: server/utils/query.ts
================================================
import type { SQL } from 'drizzle-orm'
import type { PgColumn, PgSelect } from 'drizzle-orm/pg-core'
import { and, eq, gte, ilike, inArray, lte } from 'drizzle-orm'
import { z } from 'zod'

export const filterSchema = z.array(
  z.union([
    z.object({
      col: z.string(),
      op: z.literal('between'),
      v: z.tuple([z.string(), z.string()])
    }),
    z.object({
      col: z.string(),
      op: z.literal('in'),
      v: z.array(z.string()).min(1)
    }),
    z.object({
      col: z.string(),
      op: z.literal('like'),
      v: z.string()
    }),
    z.object({
      col: z.string(),
      op: z.literal('eq'),
      v: z.string()
    })
  ])
)

export function processFilters(
  filters: z.infer<typeof filterSchema>,
  columns: Record<string, PgColumn>
): SQL[] {
  const sqlFilters: SQL[] = []

  for (const filter of filters) {
    if (filter.col in columns) {
      const columnKey = filter.col as keyof typeof columns
      const column = columns[columnKey]
      if (filter.op === 'between') {
        sqlFilters.push(
          and(
            gte(column, new Date(filter.v[0])),
            lte(column, new Date(filter.v[1]))
          )!
        )
      } else if (filter.op === 'in') {
        sqlFilters.push(
          inArray(column, filter.v)
        )
      } else if (filter.op === 'like') {
        sqlFilters.push(
          ilike(column, `%${filter.v}%`)
        )
      } else if (filter.op === 'eq') {
        sqlFilters.push(
          eq(column, filter.v)
        )
      }
    }
  }

  return sqlFilters
}

export function withFilters<T extends PgSelect>(
  qb: T,
  filters: SQL[]
) {
  return filters.length ? qb.where(and(...filters)) : qb
}



================================================
FILE: server/utils/runtimeConfig.ts
================================================
import type { NitroRuntimeConfig } from 'nitropack/types'
import { config } from 'dotenv'

let runtimeConfigInstance: NitroRuntimeConfig

export const generateRuntimeConfig = () => ({
  preset: process.env.NUXT_NITRO_PRESET,
  betterAuthSecret: process.env.NUXT_BETTER_AUTH_SECRET,
  // Stripe
  stripeSecretKey: process.env.NUXT_STRIPE_SECRET_KEY,
  stripeWebhookSecret: process.env.NUXT_STRIPE_WEBHOOK_SECRET,
  stripePriceIdProMonth: process.env.NUXT_STRIPE_PRICE_ID_PRO_MONTH,
  stripePriceIdProYear: process.env.NUXT_STRIPE_PRICE_ID_PRO_YEAR,
  // Polar
  polarServer: process.env.NUXT_POLAR_SERVER,
  polarAccessToken: process.env.NUXT_POLAR_ACCESS_TOKEN,
  polarWebhookSecret: process.env.NUXT_POLAR_WEBHOOK_SECRET,
  polarProductIdProMonth: process.env.NUXT_POLAR_PRODUCT_ID_PRO_MONTH,
  polarProductIdProYear: process.env.NUXT_POLAR_PRODUCT_ID_PRO_YEAR,
  // Resend
  resendApiKey: process.env.NUXT_RESEND_API_KEY,
  // Github
  githubClientId: process.env.NUXT_GH_CLIENT_ID,
  githubClientSecret: process.env.NUXT_GH_CLIENT_SECRET,
  // Google
  googleClientId: process.env.NUXT_GOOGLE_CLIENT_ID,
  googleClientSecret: process.env.NUXT_GOOGLE_CLIENT_SECRET,
  // DB
  redisUrl: process.env.NUXT_REDIS_URL,
  databaseUrl: process.env.NUXT_DATABASE_URL,
  public: {
    baseURL: process.env.NUXT_APP_URL,
    appName: process.env.NUXT_APP_NAME,
    appEnv: process.env.NODE_ENV,
    appRepo: process.env.NUXT_APP_REPO,
    appNotifyEmail: process.env.NUXT_APP_NOTIFY_EMAIL,
    appContactEmail: process.env.NUXT_APP_CONTACT_EMAIL,
    payment: process.env.NUXT_PAYMENT || 'stripe',
    auth: {
      redirectUserTo: '/',
      redirectGuestTo: '/signin'
    }
  }
})

if (typeof useRuntimeConfig !== 'undefined') {
  runtimeConfigInstance = useRuntimeConfig()
} else {
  // for cli: npm run auth:schema
  config()
  runtimeConfigInstance = generateRuntimeConfig() as NitroRuntimeConfig
}

export const runtimeConfig = runtimeConfigInstance



================================================
FILE: server/utils/stripe.ts
================================================
import type { Subscription } from '@better-auth/stripe'
import { stripe } from '@better-auth/stripe'
import { eq } from 'drizzle-orm'
import Stripe from 'stripe'
import { user as userTable } from '../database/schema'
import { logAuditEvent } from './auditLogger'
import { useDB } from './db'
import { runtimeConfig } from './runtimeConfig'

const createStripeClient = () => {
  return new Stripe(runtimeConfig.stripeSecretKey!)
}

export const ensureStripeCustomer = async (user: User) => {
  const client = createStripeClient()

  // Check if customer already exists
  const customers = await client.customers.list({
    email: user.email,
    limit: 1
  })

  if (customers.data.length > 0) {
    return customers.data[0]
  }

  // Create new customer if not exists
  const customer = await client.customers.create({
    email: user.email,
    name: user.name,
    metadata: {
      userId: user.id
    }
  })

  return customer
}

const getUserByStripeCustomerId = async (stripeCustomerId: string) => {
  const db = await useDB()
  const user = db.query.user.findFirst({
    where: eq(userTable.stripeCustomerId, stripeCustomerId)
  })
  return user
}

const addPaymentLog = async (action: string, subscription: Subscription) => {
  const user = await getUserByStripeCustomerId(subscription.stripeCustomerId!)
  await logAuditEvent({
    userId: user!.id,
    category: 'payment',
    action: `${action}:${subscription.plan}`,
    targetType: 'stripeCustomerId',
    targetId: subscription.stripeCustomerId,
    status: 'success'
  })
}

export const setupStripe = () => stripe({
  stripeClient: createStripeClient(),
  stripeWebhookSecret: runtimeConfig.stripeWebhookSecret,
  createCustomerOnSignUp: runtimeConfig.public.payment == 'stripe',
  subscription: {
    enabled: true,
    plans: [
      {
        name: 'pro-monthly',
        priceId: runtimeConfig.stripePriceIdProMonth,
        freeTrial: {
          days: 14,
          onTrialStart: async (subscription) => {
            // Called when a trial starts
            await addPaymentLog('trial_start', subscription)
          },
          onTrialEnd: async ({ subscription }) => {
            // Called when a trial ends
            await addPaymentLog('trial_end', subscription)
          },
          onTrialExpired: async (subscription) => {
            // Called when a trial expires without conversion
            await addPaymentLog('trial_expired', subscription)
          }
        }
      },
      {
        name: 'pro-yearly',
        priceId: runtimeConfig.stripePriceIdProYear,
        freeTrial: {
          days: 14,
          onTrialStart: async (subscription) => {
            // Called when a trial starts
            await addPaymentLog('trial_start', subscription)
          },
          onTrialEnd: async ({ subscription }) => {
            // Called when a trial ends
            await addPaymentLog('trial_end', subscription)
          },
          onTrialExpired: async (subscription) => {
            // Called when a trial expires without conversion
            await addPaymentLog('trial_expired', subscription)
          }
        }
      }
    ],
    onSubscriptionComplete: async ({ subscription }) => {
      // Called when a subscription is successfully created
      await addPaymentLog('subscription_created', subscription)
    },
    onSubscriptionUpdate: async ({ subscription }) => {
      // Called when a subscription is updated
      await addPaymentLog('subscription_updated', subscription)
    },
    onSubscriptionCancel: async ({ subscription }) => {
      // Called when a subscription is canceled
      await addPaymentLog('subscription_canceled', subscription)
    },
    onSubscriptionDeleted: async ({ subscription }) => {
      // Called when a subscription is deleted
      await addPaymentLog('subscription_deleted', subscription)
    }
  }
})



================================================
FILE: shared/utils/types.ts
================================================
import type { user } from '~~/server/database/schema'

export type User = typeof user.$inferSelect



================================================
FILE: tests/setup.ts
================================================
import { beforeAll } from 'vitest'

beforeAll(() => {
  // Global setup code can be added here
})



================================================
FILE: tests/e2e/app.test.ts
================================================
import { createPage, setup } from '@nuxt/test-utils/e2e'
import { afterEach, beforeEach, describe, expect, it } from 'vitest'

describe('app', async () => {
  await setup({ host: process.env.NUXT_TEST_APP_URL })

  beforeEach(() => {
    // tell vitest we use mocked time
    console.log('beforeEach test')
  })

  afterEach(() => {
    // restoring date after each test run
    console.log('afterEach test')
  })

  it('should load homepage successfully', async () => {
    const page = await createPage('/')
    const h1 = await page.$('h1')
    expect(await h1?.textContent()).eq('NuxSaaS')
  })
})



================================================
FILE: tests/e2e/auth.test.ts
================================================
import { createPage, setup } from '@nuxt/test-utils/e2e'
import { describe, expect, it } from 'vitest'

describe('auth', async () => {
  const host = process.env.NUXT_TEST_APP_URL
  await setup({
    host
  })

  describe('guest routes', () => {
    it('should allow guest access to signin page', async () => {
      const page = await createPage('/signin')
      const signinButton = await page.$('button:has-text("Sign In")')
      expect(signinButton).toBeTruthy()
    })

    it('should redirect authenticated user away from signin page', async () => {
      const page = await createPage('/signin')
      await page.fill('input[name="email"]', process.env.NUXT_TEST_EMAIL!)
      await page.fill('input[name="password"]', process.env.NUXT_TEST_PASSWORD!)
      await page.click('button[type="submit"]')
      await page.waitForLoadState('networkidle')
      expect(page.url()).toEqual(`${host}/`)

      // // Try accessing signin page while logged in
      await page.goto(`${host}/signin`)
      await page.waitForLoadState('networkidle')
      expect(page.url()).toEqual(`${host}/`)
    })
  })

  describe('auth disabled routes', () => {
    it('should allow guest access to pricing page', async () => {
      const page = await createPage('/pricing')
      await page.waitForLoadState('networkidle')
      expect(page.url()).toEqual(`${host}/pricing`)
      const salesButton = await page.$('a:has-text("Contact Sales")')
      expect(salesButton).toBeTruthy()
    })

    it('should allow user access to pricing page', async () => {
      const page = await createPage('/signin')
      await page.fill('input[name="email"]', process.env.NUXT_TEST_EMAIL!)
      await page.fill('input[name="password"]', process.env.NUXT_TEST_PASSWORD!)
      await page.click('button[type="submit"]')
      await page.waitForLoadState('networkidle')
      expect(page.url()).toEqual(`${host}/`)

      // // Try accessing signin page while logged in
      await page.goto(`${host}/pricing`)
      await page.waitForLoadState('networkidle')
      expect(page.url()).toEqual(`${host}/pricing`)
      const salesButton = await page.$('a:has-text("Contact Sales")')
      expect(salesButton).toBeTruthy() })
  })

  describe('guest should not access auth only pages.', () => {
    it('should redirect unauthenticated user to signin when accessing profile', async () => {
      const page = await createPage('/profile')
      await page.waitForLoadState('networkidle')
      expect(page.url()).toContain('/signin')
      expect(page.url()).toContain('redirect=/profile')
    })

    it('should redirect unauthenticated user to signin when accessing admin', async () => {
      const page = await createPage('/admin')
      await page.waitForLoadState('networkidle')
      expect(page.url()).toContain('/signin')
      expect(page.url()).toContain('redirect=/admin')
    })

    it('should redirect to localized signin with correct redirect parameter', async () => {
      const page = await createPage('/fr/admin')
      await page.waitForLoadState('networkidle')

      expect(page.url()).toContain('/fr/signin')
      expect(page.url()).toContain('redirect=/fr/admin')
    })
  })

  describe('admin users can access admin pages', () => {
    it('authenticated user can access profile page', async () => {
      // Login as regular user
      const page = await createPage('/signin')
      await page.fill('input[name="email"]', process.env.NUXT_TEST_EMAIL!)
      await page.fill('input[name="password"]', process.env.NUXT_TEST_PASSWORD!)
      await page.click('button[type="submit"]')
      await page.waitForLoadState('networkidle')

      // Try accessing profile page
      await page.goto(`${host}/profile`)
      await page.waitForLoadState('networkidle')
      expect(page.url()).toContain('/profile')
    })

    it('should redirect non-admin user to 403', async () => {
      // Login as regular user
      const page = await createPage('/signin')
      await page.fill('input[name="email"]', process.env.NUXT_TEST_EMAIL!)
      await page.fill('input[name="password"]', process.env.NUXT_TEST_PASSWORD!)
      await page.click('button[type="submit"]')
      await page.waitForLoadState('networkidle')

      // Try accessing admin page
      await page.goto(`${host}/admin`)
      await page.waitForLoadState('networkidle')
      expect(page.url()).toContain('/403')
    })

    it('admin user can access admin dashboard', async () => {
      // Login as admin
      const page = await createPage('/signin')
      await page.fill('input[name="email"]', process.env.NUXT_ADMIN_EMAIL!)
      await page.fill('input[name="password"]', process.env.NUXT_ADMIN_PASSWORD!)
      await page.click('button[type="submit"]')
      await page.waitForLoadState('networkidle')

      // Access admin page
      await page.goto(`${host}/admin`)
      await page.waitForLoadState('networkidle')
      expect(page.url()).toContain('/admin/dashboard')
    })
  })
})



================================================
FILE: tests/e2e/i18n.test.ts
================================================
import { createPage, setup } from '@nuxt/test-utils/e2e'
import { describe, expect, it } from 'vitest'

describe('i18n', async () => {
  await setup({ host: process.env.NUXT_TEST_APP_URL })

  it('should load homepage in different languages', async () => {
    // English
    const enPage = await createPage('/')
    const startBtn = await enPage.$('a:has-text("Get Started")')
    expect(startBtn).toBeTruthy()

    // French
    const frPage = await createPage('/fr')
    const frTitle = await frPage.$('a:has-text("Commencer")')
    expect(frTitle).toBeTruthy()

    // Japanese
    const jaPage = await createPage('/ja')
    const jaTitle = await jaPage.$('a:has-text("始めましょう")')
    expect(jaTitle).toBeTruthy()

    // Chinese
    const zhPage = await createPage('/zh-CN')
    const zhTitle = await zhPage.$('a:has-text("开始使用")')
    expect(zhTitle).toBeTruthy()
  })

  it('should handle language switching', async () => {
    const page = await createPage('/')

    // Switch to French
    await page.click('button[aria-label="Change language"]')
    await page.click('span:has-text("Français")')
    await page.waitForLoadState('networkidle')

    expect(page.url()).toContain('/fr')
  })

  it('should maintain language preference across pages', async () => {
    // Navigate to signin page
    const page = await createPage('/fr')
    await page.click('a:has-text("Commencer")')
    await page.waitForLoadState('networkidle')
    expect(page.url()).toContain('/fr/signin')

    // Navigate to signup page
    await page.click('a:has-text("Créez-en un")')
    await page.waitForURL('**/fr/signup')
    expect(page.url()).toContain('/fr/signup')

    // Navigate back to signin page
    await page.click('a:has-text("Connectez-vous ici")')
    await page.waitForURL('**/fr/signin')
    expect(page.url()).toContain('/fr/signin')

    // Navigate to forgot-password page
    await page.click('a:has-text("Mot de passe oublié")')
    await page.waitForURL('**/fr/forgot-password')
    expect(page.url()).toContain('/fr/forgot-password')

    // Navigate back to signin page
    await page.click('a:has-text("Retour à la connexion")')
    await page.waitForURL('**/fr/signin')
    expect(page.url()).toContain('/fr/signin')

    // Navigate back to home page
    await page.click(`span:has-text("${process.env.NUXT_APP_NAME}")`)
    await page.waitForURL('**/fr')
    const isEndsWithFr = page.url().endsWith('/fr')
    expect(isEndsWithFr).toBeTruthy()

    // Navigate to pricing page
    await page.click(`a:has-text("Tarification")`)
    await page.waitForURL('**/fr/pricing')
    expect(page.url()).toContain('/fr/pricing')
  })
})



================================================
FILE: tests/e2e/signin.test.ts
================================================
import { createPage, setup } from '@nuxt/test-utils/e2e'
import { describe, expect, it } from 'vitest'

describe('signin', async () => {
  await setup({ host: process.env.NUXT_TEST_APP_URL })

  it('should show signin form', async () => {
    const page = await createPage('/signin')
    const title = await page.$('h1')
    expect(await title?.textContent()).toContain(`Welcome to ${process.env.NUXT_APP_NAME}`)
  })

  it('should validate form fields', async () => {
    const page = await createPage('/signin')
    await page.fill('input[name="email"]', 'invalid-email')
    await page.fill('input[name="password"]', '123')

    await page.click('h1')

    const errors = await page.$$('[id^="v-"][id$="-error"]')
    expect(errors.length).toEqual(2)
    expect(await errors[0]?.textContent()).toEqual('Invalid email address')
    expect(await errors[1]?.textContent()).toEqual('Password must be at least 8 characters')
  })

  it('should validate form fields in Français', async () => {
    const page = await createPage('/fr/signin')
    await page.fill('input[name="email"]', 'invalid-email')
    await page.fill('input[name="password"]', '123')

    await page.click('h1')

    const errors = await page.$$('[id^="v-"][id$="-error"]')
    expect(errors.length).toEqual(2)
    expect(await errors[0]?.textContent()).toEqual('Adresse e-mail invalide')
    expect(await errors[1]?.textContent()).toEqual('Le mot de passe doit contenir au moins 8 caractères')
  })

  it('should submit valid signup form', async () => {
    const page = await createPage('/signin')

    await page.fill('input[name="email"]', 'test@example.com')
    await page.fill('input[name="password"]', 'password123')

    await page.click('h1')

    const errors = await page.$$('[id^="v-"][id$="-error"]')
    expect(errors.length).toEqual(0)
  })

  it('should have working social login buttons', async () => {
    const page = await createPage('/signin')

    const googleButton = await page.$('button:has-text("Google")')
    const githubButton = await page.$('button:has-text("Github")')

    expect(googleButton).toBeTruthy()
    expect(githubButton).toBeTruthy()
  })
})



================================================
FILE: tests/e2e/signup.test.ts
================================================
import { createPage, setup } from '@nuxt/test-utils/e2e'
import { describe, expect, it } from 'vitest'

describe('signup', async () => {
  await setup({ host: process.env.NUXT_TEST_APP_URL })

  it('should show signup form', async () => {
    const page = await createPage('/signup')
    const title = await page.$('h1')
    expect(await title?.textContent()).toContain('Create your account')
  })

  it('should validate form fields', async () => {
    const page = await createPage('/signup')
    await page.fill('input[name="name"]', 'te')
    await page.fill('input[name="email"]', 'invalid-email')
    await page.fill('input[name="password"]', '123')
    await page.fill('input[name="confirmPassword"]', '1234')

    await page.click('h1')

    const errors = await page.$$('[id^="v-"][id$="-error"]')
    expect(errors.length).toEqual(4)
    expect(await errors[0]?.textContent()).toEqual('Name must be at least 5 characters')
    expect(await errors[1]?.textContent()).toEqual('Invalid email address')
    expect(await errors[2]?.textContent()).toEqual('Password must be at least 8 characters')
    expect(await errors[3]?.textContent()).toEqual('Passwords don\'t match')
  })

  it('should validate form fields in Français', async () => {
    const page = await createPage('/fr/signup')
    await page.fill('input[name="name"]', 'te')
    await page.fill('input[name="email"]', 'invalid-email')
    await page.fill('input[name="password"]', '123')
    await page.fill('input[name="confirmPassword"]', '1234')

    await page.click('h1')

    const errors = await page.$$('[id^="v-"][id$="-error"]')
    expect(errors.length).toEqual(4)
    expect(await errors[0]?.textContent()).toEqual('Le nom doit contenir au moins 5 caractères')
    expect(await errors[1]?.textContent()).toEqual('Adresse email invalide')
    expect(await errors[2]?.textContent()).toEqual('Le mot de passe doit contenir au moins 8 caractères')
    expect(await errors[3]?.textContent()).toEqual('Les mots de passe ne correspondent pas')
  })

  it('should submit valid signup form', async () => {
    const page = await createPage('/signup')

    await page.fill('input[name="name"]', 'Test User')
    await page.fill('input[name="email"]', 'test@example.com')
    await page.fill('input[name="password"]', 'password123')
    await page.fill('input[name="confirmPassword"]', 'password123')

    await page.click('h1')

    const errors = await page.$$('[id^="v-"][id$="-error"]')
    expect(errors.length).toEqual(0)
  })

  it('should have working social login buttons', async () => {
    const page = await createPage('/signup')

    const googleButton = await page.$('button:has-text("Google")')
    const githubButton = await page.$('button:has-text("Github")')

    expect(googleButton).toBeTruthy()
    expect(githubButton).toBeTruthy()
  })
})



================================================
FILE: .github/FUNDING.yml
================================================
patreon: NuxSaaS



================================================
FILE: .husky/pre-commit
================================================
npm run lint -- --max-warnings=0

